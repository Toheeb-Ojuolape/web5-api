var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var src_exports = {};
__export(src_exports, {
  DID: () => DID,
  anchor: () => anchor,
  generateKeyPair: () => generateKeyPair,
  resolve: () => resolve,
  sign: () => sign,
  verify: () => verify3
});
module.exports = __toCommonJS(src_exports);

// src/did.js
var import_ion_sdk2 = require("@decentralized-identity/ion-sdk");

// src/utils.js
var import_cross_fetch = __toESM(require("cross-fetch"), 1);
var import_ion_pow_sdk = __toESM(require("@decentralized-identity/ion-pow-sdk"), 1);
var ed25519 = __toESM(require("@noble/ed25519"), 1);
var secp256k1 = __toESM(require("@noble/secp256k1"), 1);
var import_base64 = require("multiformats/bases/base64");
var import_ion_sdk = require("@decentralized-identity/ion-sdk");
var import_sha2 = require("multiformats/hashes/sha2");
var fetch = globalThis.fetch ?? import_cross_fetch.default;
var keyGenerators = {
  "Ed25519": import_ion_sdk.IonKey.generateEd25519OperationKeyPair,
  "EdDSA": import_ion_sdk.IonKey.generateEd25519OperationKeyPair,
  "secp256k1": import_ion_sdk.IonKey.generateEs256kOperationKeyPair,
  "ES256K": import_ion_sdk.IonKey.generateEs256kOperationKeyPair
};
async function generateKeyPair(type = "secp256k1") {
  const keyGeneratorFn = keyGenerators[type];
  if (!keyGeneratorFn) {
    throw new Error("Unsupported key type");
  }
  const [publicJwk, privateJwk] = await keyGeneratorFn();
  return { publicJwk, privateJwk };
}
async function sign(params = {}) {
  const { header = {}, payload, privateJwk } = params;
  let signer;
  let signerOpts;
  switch (privateJwk.crv) {
    case "Ed25519":
      header.alg = "EdDSA";
      signer = ed25519;
      break;
    case "secp256k1":
      header.alg = "ES256K";
      signer = secp256k1;
      signerOpts = { der: false };
      break;
    default:
      throw new Error("Unsupported cryptographic type");
  }
  const textEncoder = new TextEncoder();
  const headerStr = JSON.stringify(header);
  const headerBytes = textEncoder.encode(headerStr);
  const headerBase64Url = import_base64.base64url.baseEncode(headerBytes);
  const payloadStr = JSON.stringify(payload);
  const payloadBytes = textEncoder.encode(payloadStr);
  const payloadBase64Url = import_base64.base64url.baseEncode(payloadBytes);
  const message = `${headerBase64Url}.${payloadBase64Url}`;
  let messageBytes = textEncoder.encode(message);
  if (privateJwk.crv === "secp256k1") {
    messageBytes = await import_sha2.sha256.encode(messageBytes);
  }
  const privateKeyBytes = import_base64.base64url.baseDecode(privateJwk.d);
  const signatureBytes = await signer.sign(messageBytes, privateKeyBytes, signerOpts);
  const signature = import_base64.base64url.baseEncode(signatureBytes);
  return `${message}.${signature}`;
}
async function verify3(params = {}) {
  const { jws, publicJwk } = params;
  const [headerBase64Url, payloadBase64Url, signatureBase64Url] = jws.split(".");
  const message = `${headerBase64Url}.${payloadBase64Url}`;
  const messageBytes = new TextEncoder().encode(message);
  const signatureBytes = import_base64.base64url.baseDecode(signatureBase64Url);
  switch (publicJwk.crv) {
    case "secp256k1": {
      const xBytes = import_base64.base64url.baseDecode(publicJwk.x);
      const yBytes = import_base64.base64url.baseDecode(publicJwk.y);
      const publicKeyBytes = new Uint8Array(xBytes.length + yBytes.length + 1);
      publicKeyBytes.set([4], 0);
      publicKeyBytes.set(xBytes, 1);
      publicKeyBytes.set(yBytes, xBytes.length + 1);
      const hashedMessage = await import_sha2.sha256.encode(messageBytes);
      return secp256k1.verify(signatureBytes, hashedMessage, publicKeyBytes);
    }
    case "Ed25519": {
      const publicKeyBytes = import_base64.base64url.baseDecode(publicJwk.x);
      return ed25519.verify(signatureBytes, messageBytes, publicKeyBytes);
    }
    default:
      throw new Error("Unsupported cryptographic type");
  }
}
async function resolve(didUri, options = {}) {
  const { nodeEndpoint = "https://beta.discover.did.microsoft.com/1.0/identifiers" } = options;
  const response = await fetch(`${nodeEndpoint}/${didUri}`);
  if (response.status >= 400) {
    throw new Error(response.statusText);
  }
  return response.json();
}
async function anchor(anchorRequest, options = {}) {
  const {
    challengeEndpoint = "https://beta.ion.msidentity.com/api/v1.0/proof-of-work-challenge",
    solutionEndpoint = "https://beta.ion.msidentity.com/api/v1.0/operations"
  } = options;
  return import_ion_pow_sdk.default.submitIonRequest(challengeEndpoint, solutionEndpoint, JSON.stringify(anchorRequest));
}

// src/did.js
var DID = class {
  #ops;
  #opQueue = Promise.resolve();
  #longForm;
  #longFormPromise;
  #generateKeyPair;
  constructor(options = {}) {
    this.#ops = options.ops || [];
    this.#generateKeyPair = options.generateKeyPair || generateKeyPair;
    if (!this.#ops.length) {
      this.#ops.push(this.generateOperation("create", options.content || {}, false));
    }
  }
  async generateOperation(type, content, commit = true) {
    return this.#addToOpQueue(() => this.#generateOperation(type, content, commit));
  }
  async #addToOpQueue(callback = () => Promise.resolve()) {
    const opQueue = this.#opQueue;
    this.#opQueue = new Promise((resolve2, reject) => {
      opQueue.finally(() => callback().then(resolve2, reject));
    });
    return this.#opQueue;
  }
  async #generateOperation(type, content, commit) {
    let lastOp = this.#ops[this.#ops.length - 1];
    if (lastOp && lastOp.operation === "deactivate") {
      throw "Cannot perform further operations on a deactivated DID";
    }
    let op = {
      operation: type,
      content
    };
    if (type !== "create") {
      op.previous = this.#ops.reduce((last, op2) => {
        return op2.operation === type || op2.operation === "recover" && (type === "deactivate" || type === "update") ? op2 : last;
      }, this.#ops[0]);
    }
    if (type === "create" || type === "recover") {
      op.recovery = await this.#generateKeyPair();
    }
    if (type !== "deactivate") {
      op.update = await this.#generateKeyPair();
    }
    if (commit) {
      this.#ops.push(op);
    }
    return op;
  }
  async generateRequest(payload = 0, options = {}) {
    let op;
    if (typeof payload === "number") {
      await this.#addToOpQueue();
      op = await this.getOperation(payload);
    } else {
      op = payload;
    }
    switch (op.operation) {
      case "update":
        return import_ion_sdk2.IonRequest.createUpdateRequest({
          didSuffix: await this.getSuffix(),
          signer: options.signer || import_ion_sdk2.LocalSigner.create(op.previous.update.privateJwk),
          updatePublicKey: op.previous.update.publicJwk,
          nextUpdatePublicKey: op.update.publicJwk,
          servicesToAdd: op.content?.addServices,
          idsOfServicesToRemove: op.content?.removeServices,
          publicKeysToAdd: op.content?.addPublicKeys,
          idsOfPublicKeysToRemove: op.content?.removePublicKeys
        });
      case "recover":
        return import_ion_sdk2.IonRequest.createRecoverRequest({
          didSuffix: await this.getSuffix(),
          signer: options.signer || import_ion_sdk2.LocalSigner.create(op.previous.recovery.privateJwk),
          recoveryPublicKey: op.previous.recovery.publicJwk,
          nextRecoveryPublicKey: op.recovery.publicJwk,
          nextUpdatePublicKey: op.update.publicJwk,
          document: op.content
        });
      case "deactivate":
        return import_ion_sdk2.IonRequest.createDeactivateRequest({
          didSuffix: await this.getSuffix(),
          recoveryPublicKey: op.previous.recovery.publicJwk,
          signer: options.signer || import_ion_sdk2.LocalSigner.create(op.previous.recovery.privateJwk)
        });
      case "create":
      default:
        return import_ion_sdk2.IonRequest.createCreateRequest({
          recoveryKey: op.recovery.publicJwk,
          updateKey: op.update.publicJwk,
          document: op.content
        });
    }
  }
  async getAllOperations() {
    return Promise.all(this.#ops);
  }
  async getOperation(index) {
    return this.#ops[index];
  }
  async getState() {
    const [shortForm, longForm, ops] = await Promise.all([
      this.getURI("short"),
      this.getURI(),
      this.getAllOperations()
    ]);
    return { shortForm, longForm, ops };
  }
  async getSuffix() {
    const uri = await this.getURI("short");
    return uri.split(":").pop();
  }
  async getURI(form = "long") {
    if (this.#longFormPromise) {
      await this.#longFormPromise;
    }
    if (!this.#longForm) {
      this.#longFormPromise = this.#addToOpQueue(async () => {
        const create = await this.getOperation(0);
        return import_ion_sdk2.IonDid.createLongFormDid({
          recoveryKey: create.recovery.publicJwk,
          updateKey: create.update.publicJwk,
          document: create.content
        });
      });
      this.#longForm = await this.#longFormPromise;
      this.#longFormPromise = void 0;
    }
    return !form || form === "long" ? this.#longForm : this.#longForm.split(":").slice(0, -1).join(":");
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DID,
  anchor,
  generateKeyPair,
  resolve,
  sign,
  verify
});
//# sourceMappingURL=index.js.map
