{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/did.js", "../../src/utils.js"],
  "sourcesContent": ["export { DID } from './did.js';\r\nexport { anchor, generateKeyPair, resolve, sign, verify } from './utils.js';", "import { IonDid, IonRequest, LocalSigner } from '@decentralized-identity/ion-sdk';\r\nimport { generateKeyPair } from './utils.js';\r\n\r\nexport class DID {\r\n  #ops;\r\n  #opQueue = Promise.resolve();\r\n  #longForm;\r\n  #longFormPromise;\r\n  #generateKeyPair;\r\n\r\n  constructor(options = { }) {\r\n    this.#ops = options.ops || [ ];\r\n    this.#generateKeyPair = options.generateKeyPair || generateKeyPair;\r\n    if (!this.#ops.length) {\r\n      this.#ops.push(this.generateOperation('create', options.content || { }, false));\r\n    }\r\n  }\r\n\r\n  async generateOperation(type, content, commit = true) {\r\n    return this.#addToOpQueue(() => this.#generateOperation(type, content, commit));\r\n  }\r\n\r\n  async #addToOpQueue(callback = () => Promise.resolve()) {\r\n    const opQueue = this.#opQueue;\r\n    this.#opQueue = new Promise((resolve, reject) => {\r\n      opQueue.finally(() => callback().then(resolve, reject));\r\n    });\r\n    return this.#opQueue;\r\n  }\r\n\r\n  async #generateOperation(type, content, commit) {\r\n    let lastOp = this.#ops[this.#ops.length - 1];\r\n    if (lastOp && lastOp.operation === 'deactivate') {\r\n      throw 'Cannot perform further operations on a deactivated DID';\r\n    }\r\n    let op = {\r\n      operation: type,\r\n      content\r\n    };\r\n    if (type !== 'create') {\r\n      op.previous = this.#ops.reduce((last, op) => {\r\n        return op.operation === type || (op.operation === 'recover' && (type === 'deactivate' || type === 'update')) ? op : last;\r\n      }, this.#ops[0]);\r\n    }\r\n    if (type === 'create' || type === 'recover') {\r\n      op.recovery = await this.#generateKeyPair();\r\n    }\r\n    if (type !== 'deactivate') {\r\n      op.update = await this.#generateKeyPair();\r\n    }\r\n    if (commit) {\r\n      this.#ops.push(op);\r\n    }\r\n\r\n    return op;\r\n  }\r\n\r\n  async generateRequest(payload = 0, options = { }) {\r\n    let op;\r\n    if (typeof payload === 'number') {\r\n      await this.#addToOpQueue();\r\n      op = await this.getOperation(payload);\r\n    } else {\r\n      op = payload;\r\n    }\r\n\r\n    switch (op.operation) {\r\n      case 'update':\r\n        return IonRequest.createUpdateRequest({\r\n          didSuffix: await this.getSuffix(),\r\n          signer: options.signer || LocalSigner.create(op.previous.update.privateJwk),\r\n          updatePublicKey: op.previous.update.publicJwk,\r\n          nextUpdatePublicKey: op.update.publicJwk,\r\n          servicesToAdd: op.content?.addServices,\r\n          idsOfServicesToRemove: op.content?.removeServices,\r\n          publicKeysToAdd: op.content?.addPublicKeys,\r\n          idsOfPublicKeysToRemove: op.content?.removePublicKeys\r\n        });\r\n\r\n      case 'recover':\r\n        return IonRequest.createRecoverRequest({\r\n          didSuffix: await this.getSuffix(),\r\n          signer: options.signer || LocalSigner.create(op.previous.recovery.privateJwk),\r\n          recoveryPublicKey: op.previous.recovery.publicJwk,\r\n          nextRecoveryPublicKey: op.recovery.publicJwk,\r\n          nextUpdatePublicKey: op.update.publicJwk,\r\n          document: op.content\r\n        });\r\n\r\n      case 'deactivate':\r\n        return IonRequest.createDeactivateRequest({\r\n          didSuffix: await this.getSuffix(),\r\n          recoveryPublicKey: op.previous.recovery.publicJwk,\r\n          signer: options.signer || LocalSigner.create(op.previous.recovery.privateJwk)\r\n        });\r\n\r\n      case 'create':\r\n      default:\r\n        return IonRequest.createCreateRequest({\r\n          recoveryKey: op.recovery.publicJwk,\r\n          updateKey: op.update.publicJwk,\r\n          document: op.content\r\n        });\r\n    }\r\n  }\r\n\r\n  async getAllOperations() {\r\n    return Promise.all(this.#ops);\r\n  }\r\n\r\n  async getOperation(index) {\r\n    return this.#ops[index];\r\n  }\r\n\r\n  async getState() {\r\n    const [ shortForm, longForm, ops ] = await Promise.all([\r\n      this.getURI('short'),\r\n      this.getURI(),\r\n      this.getAllOperations()\r\n    ]);\r\n    return { shortForm, longForm, ops };\r\n  }\r\n\r\n  /**\r\n   * returns the suffix portion of the DID string for the DID URI the class instance represents\r\n   * @example\r\n   * <caption>example DID URI: `did:ion:EiCZws6U61LV3YmvxmOIlt4Ap5RSJdIkb_lJXhuUPqQYBg`</caption>\r\n   *\r\n   * // returns: EiCZws6U61LV3YmvxmOIlt4Ap5RSJdIkb_lJXhuUPqQYBg\r\n   * did.getSuffix()\r\n   * @returns {string} suffix\r\n   */\r\n  async getSuffix() {\r\n    const uri = await this.getURI('short');\r\n    return uri.split(':').pop();\r\n  }\r\n\r\n  /**\r\n   * returns either the long or short form URI for the DID based on the form provided\r\n   * @param {'long' | 'short'} form - There are two forms of ION DID URI, the Long-Form URI, which can\r\n   * be used instantly without anchoring an ION DID, and the Short-Form URI, which is only\r\n   * resolvable after a DID has been published to the ION network.\r\n   * @returns {Promise<string>}\r\n   */\r\n  async getURI(form = 'long') {\r\n    if (this.#longFormPromise) {\r\n      await this.#longFormPromise;\r\n    }\r\n\r\n    if (!this.#longForm) {\r\n      this.#longFormPromise = this.#addToOpQueue(async () => {\r\n        const create = await this.getOperation(0);\r\n        return IonDid.createLongFormDid({\r\n          recoveryKey: create.recovery.publicJwk,\r\n          updateKey: create.update.publicJwk,\r\n          document: create.content\r\n        });\r\n      });\r\n      this.#longForm = await this.#longFormPromise;\r\n      this.#longFormPromise = undefined;\r\n    }\r\n\r\n    return !form || form === 'long' ? this.#longForm : this.#longForm.split(':').slice(0, -1).join(':');\r\n  }\r\n}", "import crossFetch from 'cross-fetch';\r\nimport ProofOfWorkSDK from '@decentralized-identity/ion-pow-sdk';\r\n\r\nimport * as ed25519 from '@noble/ed25519';\r\nimport * as secp256k1 from '@noble/secp256k1';\r\n\r\nimport { base64url } from 'multiformats/bases/base64';\r\nimport { IonKey } from '@decentralized-identity/ion-sdk';\r\nimport { sha256 } from 'multiformats/hashes/sha2';\r\n\r\n// supports fetch in: node, browsers, and browser extensions.\r\n// uses native fetch if available in environment or falls back to a ponyfill.\r\n// 'cross-fetch' is a ponyfill that uses `XMLHTTPRequest` under the hood.\r\n// `XMLHTTPRequest` cannot be used in browser extension background service workers.\r\n// browser extensions get even more strict with `fetch` in that it cannot be referenced\r\n// indirectly.\r\nconst fetch = globalThis.fetch ?? crossFetch;\r\n\r\n/**\r\n * @typedef {object} PrivateJWK\r\n * @property {'Ed25519'|'secp256k1'} privateJWK.crv\r\n * @property {string} privateJWK.d\r\n */\r\n\r\n/**\r\n * @typedef {object} PublicJWK\r\n * @property {'Ed25519'|'secp256k1'} publicJWK.crv\r\n * @property {string} publicJWK.x\r\n * @property {string} [publicJWK.y]\r\n */\r\n\r\n/**\r\n * @typedef {object} KeyPair\r\n * @property {PrivateJWK} privateJwk\r\n * @property {PublicJWK} publicJwk\r\n */\r\n\r\nconst keyGenerators = {\r\n  'Ed25519': IonKey.generateEd25519OperationKeyPair,\r\n  'EdDSA': IonKey.generateEd25519OperationKeyPair,\r\n  'secp256k1': IonKey.generateEs256kOperationKeyPair,\r\n  'ES256K': IonKey.generateEs256kOperationKeyPair\r\n};\r\n\r\n/**\r\n * generates a keypair of the type provided\r\n * @param {'Ed25519'| 'EdDSA' | 'secp256k1' | 'ES256K'} type\r\n * @returns {KeyPair}\r\n */\r\nexport async function generateKeyPair(type = 'secp256k1') {\r\n  const keyGeneratorFn = keyGenerators[type];\r\n\r\n  if (!keyGeneratorFn) {\r\n    throw new Error('Unsupported key type');\r\n  }\r\n\r\n  const [ publicJwk, privateJwk ] = await keyGeneratorFn();\r\n  return { publicJwk, privateJwk };\r\n}\r\n\r\n/**\r\n * signs the payload provided using the key provided\r\n * @param {object} params\r\n * @param {any} params.payload - anything JSON stringifiable.\r\n * @param {object} [params.header] - any properties you want included in the header. `alg` will be included for you\r\n * @param {PrivateJWK} params.privateJwk - the key to sign with\r\n * @returns {string} compact JWS\r\n */\r\nexport async function sign(params = { }) {\r\n  const { header = { }, payload, privateJwk } = params;\r\n  let signer;\r\n  let signerOpts;\r\n\r\n  switch (privateJwk.crv) {\r\n    case 'Ed25519':\r\n      header.alg = 'EdDSA';\r\n      signer = ed25519;\r\n      break;\r\n\r\n    case 'secp256k1':\r\n      header.alg = 'ES256K';\r\n      signer = secp256k1;\r\n      signerOpts = { der: false };\r\n      break;\r\n\r\n    default:\r\n      throw new Error('Unsupported cryptographic type');\r\n  }\r\n\r\n  const textEncoder = new TextEncoder();\r\n\r\n  const headerStr = JSON.stringify(header);\r\n  const headerBytes = textEncoder.encode(headerStr);\r\n  const headerBase64Url = base64url.baseEncode(headerBytes);\r\n\r\n  const payloadStr = JSON.stringify(payload);\r\n  const payloadBytes = textEncoder.encode(payloadStr);\r\n  const payloadBase64Url = base64url.baseEncode(payloadBytes);\r\n\r\n  // this is what's going to get signed\r\n  const message = `${headerBase64Url}.${payloadBase64Url}`;\r\n  let messageBytes = textEncoder.encode(message);\r\n\r\n  if (privateJwk.crv === 'secp256k1') {\r\n    messageBytes = await sha256.encode(messageBytes);\r\n  }\r\n\r\n  const privateKeyBytes = base64url.baseDecode(privateJwk.d);\r\n\r\n  const signatureBytes = await signer.sign(messageBytes, privateKeyBytes, signerOpts);\r\n  const signature = base64url.baseEncode(signatureBytes);\r\n\r\n  return `${message}.${signature}`;\r\n}\r\n\r\n/**\r\n *  verifies the provided JWS with the provided public key\r\n * @param {object} params\r\n * @param {string} params.jws - the compact jws to verify\r\n * @param {PublicJWK} params.publicJwk - the public key used to verify the signature\r\n * @returns {boolean}\r\n */\r\nexport async function verify(params = { }) {\r\n  const { jws, publicJwk } = params;\r\n  const [ headerBase64Url, payloadBase64Url, signatureBase64Url ] = jws.split('.');\r\n\r\n  const message = `${headerBase64Url}.${payloadBase64Url}`;\r\n  const messageBytes = new TextEncoder().encode(message);\r\n\r\n  const signatureBytes = base64url.baseDecode(signatureBase64Url);\r\n\r\n  switch (publicJwk.crv) {\r\n    case 'secp256k1': {\r\n      const xBytes = base64url.baseDecode(publicJwk.x);\r\n      const yBytes = base64url.baseDecode(publicJwk.y);\r\n\r\n      const publicKeyBytes = new Uint8Array(xBytes.length + yBytes.length + 1);\r\n\r\n      // create an uncompressed public key using the x and y values from the provided JWK.\r\n      // a leading byte of 0x04 indicates that the public key is uncompressed\r\n      // (e.g. x and y values are both present)\r\n      publicKeyBytes.set([ 0x04 ], 0);\r\n      publicKeyBytes.set(xBytes, 1);\r\n      publicKeyBytes.set(yBytes, xBytes.length + 1);\r\n\r\n      const hashedMessage = await sha256.encode(messageBytes);\r\n\r\n      return secp256k1.verify(signatureBytes, hashedMessage, publicKeyBytes);\r\n    }\r\n\r\n    case 'Ed25519': {\r\n      const publicKeyBytes = base64url.baseDecode(publicJwk.x);\r\n\r\n      return ed25519.verify(signatureBytes, messageBytes, publicKeyBytes);\r\n    }\r\n\r\n    default:\r\n      throw new Error('Unsupported cryptographic type');\r\n  }\r\n}\r\n\r\n/**\r\n * resolves the ION DID provided\r\n * @param {string} didUri\r\n * @param {object} options\r\n * @param {string} [nodeEndpoint] - the resolver node\r\n * @returns\r\n */\r\nexport async function resolve(didUri, options = { }) {\r\n  const { nodeEndpoint = 'https://beta.discover.did.microsoft.com/1.0/identifiers' } = options;\r\n\r\n  const response = await fetch(`${nodeEndpoint}/${didUri}`);\r\n\r\n  if (response.status >= 400) {\r\n    throw new Error(response.statusText);\r\n  }\r\n\r\n  return response.json();\r\n}\r\n\r\nexport async function anchor(anchorRequest, options = { }) {\r\n  const {\r\n    challengeEndpoint = 'https://beta.ion.msidentity.com/api/v1.0/proof-of-work-challenge',\r\n    solutionEndpoint = 'https://beta.ion.msidentity.com/api/v1.0/operations'\r\n  } = options;\r\n\r\n  return ProofOfWorkSDK.submitIonRequest(challengeEndpoint, solutionEndpoint, JSON.stringify(anchorRequest));\r\n};"],
  "mappings": "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",
  "names": ["verify", "import_ion_sdk", "crossFetch", "verify", "ProofOfWorkSDK", "resolve", "op"]
}
