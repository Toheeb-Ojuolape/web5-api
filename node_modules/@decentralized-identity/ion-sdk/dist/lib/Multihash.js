"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const multihashes = require("multihashes");
const Encoder_1 = require("./Encoder");
const ErrorCode_1 = require("./ErrorCode");
const IonError_1 = require("./IonError");
const IonSdkConfig_1 = require("./IonSdkConfig");
const JsonCanonicalizer_1 = require("./JsonCanonicalizer");
const sha2_1 = require("multiformats/hashes/sha2");
/**
 * Class that performs hashing operations using the multihash format.
 */
class Multihash {
    /**
     * Hashes the content using the hashing algorithm specified.
     * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
     */
    static hash(content, hashAlgorithmInMultihashCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const conventionalHash = yield this.hashAsNonMultihashBytes(content, hashAlgorithmInMultihashCode);
            const multihash = multihashes.encode(conventionalHash, hashAlgorithmInMultihashCode);
            return multihash;
        });
    }
    /**
     * Hashes the content using the hashing algorithm specified as a generic (non-multihash) hash.
     * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
     * @returns A multihash bytes.
     */
    static hashAsNonMultihashBytes(content, hashAlgorithmInMultihashCode) {
        return __awaiter(this, void 0, void 0, function* () {
            let hash;
            switch (hashAlgorithmInMultihashCode) {
                case 18: // SHA256
                    hash = yield sha2_1.sha256.encode(content);
                    break;
                default:
                    throw new IonError_1.default(ErrorCode_1.default.MultihashUnsupportedHashAlgorithm, `Hash algorithm defined in multihash code ${hashAlgorithmInMultihashCode} is not supported.`);
            }
            return hash;
        });
    }
    /**
     * Canonicalize the given content, then double hashes the result using the latest supported hash algorithm, then encodes the multihash.
     * Mainly used for testing purposes.
     */
    static canonicalizeThenHashThenEncode(content, hashAlgorithmInMultihashCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const canonicalizedStringBytes = JsonCanonicalizer_1.default.canonicalizeAsBytes(content);
            const multihashEncodedString = yield Multihash.hashThenEncode(canonicalizedStringBytes, hashAlgorithmInMultihashCode);
            return multihashEncodedString;
        });
    }
    /**
     * Canonicalize the given content, then double hashes the result using the latest supported hash algorithm, then encodes the multihash.
     * Mainly used for testing purposes.
     */
    static canonicalizeThenDoubleHashThenEncode(content, hashAlgorithmInMultihashCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentBytes = JsonCanonicalizer_1.default.canonicalizeAsBytes(content);
            // Double hash.
            const intermediateHashBytes = yield Multihash.hashAsNonMultihashBytes(contentBytes, hashAlgorithmInMultihashCode);
            const multihashEncodedString = yield Multihash.hashThenEncode(intermediateHashBytes, hashAlgorithmInMultihashCode);
            return multihashEncodedString;
        });
    }
    /**
     * Hashes the content using the hashing algorithm specified then encodes the multihash bytes as string.
     * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
     */
    static hashThenEncode(content, hashAlgorithmInMultihashCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const multihashBytes = yield Multihash.hash(content, hashAlgorithmInMultihashCode);
            const multihashEncodedString = Encoder_1.default.encode(multihashBytes);
            return multihashEncodedString;
        });
    }
    /**
     * Checks if the given encoded hash is a multihash computed using the configured hashing algorithm.
     */
    static validateEncodedHashComputedUsingSupportedHashAlgorithm(encodedMultihash, inputContextForErrorLogging) {
        let multihash;
        const multihashBytes = Encoder_1.default.decodeAsBytes(encodedMultihash, inputContextForErrorLogging);
        try {
            multihash = multihashes.decode(multihashBytes);
        }
        catch (_a) {
            throw new IonError_1.default(ErrorCode_1.default.MultihashStringNotAMultihash, `Given ${inputContextForErrorLogging} string '${encodedMultihash}' is not a multihash after decoding.`);
        }
        const hashAlgorithmInMultihashCode = IonSdkConfig_1.default.hashAlgorithmInMultihashCode;
        if (hashAlgorithmInMultihashCode !== multihash.code) {
            throw new IonError_1.default(ErrorCode_1.default.MultihashUnsupportedHashAlgorithm, `Given ${inputContextForErrorLogging} uses unsupported multihash algorithm with code ${multihash.code}, ` +
                `should use ${hashAlgorithmInMultihashCode} or change IonSdkConfig to desired hashing algorithm.`);
        }
    }
}
exports.default = Multihash;
//# sourceMappingURL=Multihash.js.map