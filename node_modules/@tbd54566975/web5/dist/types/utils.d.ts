export declare function base64UrlToString(base64urlString: any): string;
export declare function bytesToObject(bytes: any): any;
/**
 * Checks if the provided data size is under the cache limit.
 * The cache limit is based on the maxDataSizeAllowedToBeEncoded defined in the DWN SDK.
 *
 * @export
 * @param {number} dataSize - The size of the data to be checked, in bytes.
 * @returns {boolean} True if the data size is less than or equal to the maximum allowed data size, false otherwise.
 *
 * @example
 * // Returns: true
 * isDataSizeUnderCacheLimit(5000);
 *
 * @example
 * // Returns: false
 * isDataSizeUnderCacheLimit(15000);
 */
export declare function isDataSizeUnderCacheLimit(dataSize: number): boolean;
/**
 * Set/detect the media type and return the data as bytes.
 */
export declare const dataToBlob: (data: any, dataFormat?: string) => {
    dataBlob: Blob;
    dataFormat: string;
};
export declare function isEmptyObject(obj: any): boolean;
/**
 * Simplistic initial implementation to check whether messages that are being routed
 * to process locally or be transported to a remote DWN are already signed.
 *
 * TODO: Consider whether cryptographic signature verification is warranted or if
 *       the naive check is sufficient given that DWNs already verify authenticity
 *       and integrity of every message.
 * @param {{}} message
 * @returns boolean
 */
export declare function isUnsignedMessage(message: any): boolean;
export declare function objectValuesBase64UrlToBytes(obj: any): {
    [k: string]: Uint8Array;
};
export declare function objectValuesBytesToBase64Url(obj: any): {
    [k: string]: string;
};
export declare function parseJson(str: any): any;
export declare function parseUrl(str: any): URL;
export declare function pascalToKebabCase(str: any): any;
export declare function getRandomInt(min: any, max: any): any;
//# sourceMappingURL=utils.d.ts.map