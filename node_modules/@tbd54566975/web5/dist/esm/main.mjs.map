{
  "version": 3,
  "sources": ["../../src/web5.ts", "../../src/vc-api.ts", "../../src/dwn-api.ts", "../../src/record.ts", "../../src/utils.ts", "../../src/protocol.ts", "../../src/did-api.ts", "../../src/app-storage.ts", "../../src/did-resolution-cache.ts"],
  "sourcesContent": ["import type { Web5Agent } from '@tbd54566975/web5-agent';\nimport type { SyncManager } from '@tbd54566975/web5-user-agent';\nimport type { DidState, DidMethodApi, DidResolverCache, DwnServiceEndpoint } from '@tbd54566975/dids';\n\n// import  { Web5ProxyAgent } from '@tbd54566975/web5-proxy-agent';\nimport { Dwn } from '@tbd54566975/dwn-sdk-js';\nimport { Web5UserAgent, ProfileApi, SyncApi } from '@tbd54566975/web5-user-agent';\nimport { DidIonApi, DidKeyApi, utils as didUtils } from '@tbd54566975/dids';\n\nimport { VcApi } from './vc-api.js';\nimport { DwnApi } from './dwn-api.js';\nimport { DidApi } from './did-api.js';\nimport { AppStorage } from './app-storage.js';\nimport { getRandomInt } from './utils.js';\nimport { DidResolutionCache } from './did-resolution-cache.js';\n\n/**\n * overrides to defaults configured for technical preview phase\n */\nexport type TechPreviewOptions = {\n  /** overrides default dwnEndpoints provided for technical preview. see `Web5.#enqueueNextSync` */\n  dwnEndpoints?: string[];\n}\n\n/**\n * optional overrides that can be provided when calling {@link Web5.connect}\n */\nexport type Web5ConnectOptions = {\n  /** a custom {@link Web5Agent}. Defaults to creating an embedded {@link Web5UserAgent} if one isnt provided */\n  web5Agent?: Web5Agent;\n  /** additional {@link DidMethodApi}s that can be used to create and resolve DID methods. defaults to did:key and did:ion */\n  didMethodApis?: DidMethodApi[];\n  /** custom cache used to store DidResolutionResults. defaults to a {@link DidResolutionCache} */\n  didResolutionCache?: DidResolverCache;\n  /** overrides to defaults configured for technical preview phase. See {@link TechPreviewOptions} */\n  techPreview?: TechPreviewOptions;\n}\n\n/**\n * @see {@link Web5ConnectOptions}\n */\ntype Web5Options = {\n  web5Agent: Web5Agent;\n  appStorage?: AppStorage;\n  connectedDid: string;\n};\n\nexport class Web5 {\n  appStorage: AppStorage;\n  dwn: DwnApi;\n  vc: VcApi;\n  #connectedDid: string;\n\n  /**\n   * Statically available DID functionality. can be used to create and resolve DIDs without calling {@link connect}.\n   * By default, can create and resolve `did:key` and `did:ion`. DID resolution results are not cached unless `connect`\n   * is called\n   */\n  static did = new DidApi({\n    didMethodApis: [new DidIonApi(), new DidKeyApi()]\n  });\n\n  /**\n   * DID functionality (e.g. creating and resolving DIDs)\n   */\n  get did() { return Web5.did; }\n\n  private static APP_DID_KEY = 'WEB5_APP_DID';\n\n  private constructor(options: Web5Options) {\n    this.#connectedDid = options.connectedDid;\n    this.dwn = new DwnApi(options.web5Agent, this.#connectedDid);\n    this.vc = new VcApi(options.web5Agent, this.#connectedDid);\n    this.appStorage ||= new AppStorage();\n  }\n\n  /**\n   * Connects to a {@link Web5Agent}. defaults to creating an embedded {@link Web5UserAgent} if one isn't provided\n   * @param options - optional overrides\n   * @returns\n   */\n  static async connect(options: Web5ConnectOptions = {}) {\n    // load app's did\n    const appStorage = new AppStorage();\n    const cachedAppDidState = await appStorage.get(Web5.APP_DID_KEY);\n    let appDidState: DidState;\n\n    if (cachedAppDidState) {\n      appDidState = JSON.parse(cachedAppDidState);\n    } else {\n      appDidState = await this.did.create('key');\n      appStorage.set(Web5.APP_DID_KEY, JSON.stringify(appDidState));\n    }\n\n    // TODO: sniff to see if remote agent is available\n    // TODO: if available,connect to remote agent using Web5ProxyAgent\n\n    // fall back to instantiating local agent\n    const profileApi = new ProfileApi();\n    let [ profile ] = await profileApi.listProfiles();\n\n    options.didMethodApis ??= [];\n\n    // override default cache used by `Web5.did`\n    Web5.did = new DidApi({\n      didMethodApis : [new DidIonApi(), new DidKeyApi(), ...options.didMethodApis],\n      cache         : options.didResolutionCache || new DidResolutionCache()\n    });\n\n    const dwn = await Dwn.create();\n    const syncManager = new SyncApi({\n      profileManager : profileApi,\n      didResolver    : Web5.did.resolver, // share the same resolver to share the same underlying cache\n      dwn            : dwn\n    });\n\n    if (!profile) {\n      const dwnUrls = options.techPreview?.dwnEndpoints || await Web5.getTechPreviewDwnEndpoints();\n      const ionCreateOptions = await DidIonApi.generateDwnConfiguration(dwnUrls);\n      const defaultProfileDid = await this.did.create('ion', ionCreateOptions);\n\n      // setting id & name as the app's did to make migration easier\n      profile = await profileApi.createProfile({\n        name        : appDidState.id,\n        did         : defaultProfileDid,\n        connections : [appDidState.id],\n      });\n\n      await syncManager.registerProfile(profile.did.id);\n    }\n\n    const agent = await Web5UserAgent.create({\n      profileManager : profileApi,\n      didResolver    : Web5.did.resolver, // share the same resolver to share the same underlying cache\n      syncManager    : syncManager,\n      dwn            : dwn,\n    });\n\n    const connectedDid = profile.did.id;\n    const web5 = new Web5({ appStorage: appStorage, web5Agent: agent, connectedDid });\n\n    Web5.#enqueueNextSync(syncManager, 1_000);\n\n    return { web5, did: connectedDid };\n  }\n\n  /**\n   * Dynamically selects up to 2 DWN endpoints that are provided\n   * by default during the Tech Preview period.\n   */\n  static async getTechPreviewDwnEndpoints(): Promise<string[]> {\n    let response: Response;\n    try {\n      response = await fetch('https://dwn.tbddev.org/.well-known/did.json');\n      if (!response.ok) {\n        throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);\n      }\n    } catch(e) {\n      console.warn('failed to get tech preview dwn endpoints:', e.message);\n      return [];\n    }\n\n    const didDoc = await response.json();\n    const [ service ] = didUtils.getServices(didDoc, { id: '#dwn', type: 'DecentralizedWebNode' });\n    const { nodes } = <DwnServiceEndpoint>service.serviceEndpoint;\n\n    // allocate up to 2 nodes for a user.\n    const dwnUrls = new Set<string>();\n    const numNodesToAllocate = Math.min(nodes.length, 2);\n\n    for (let attempts = 0; attempts < nodes.length && dwnUrls.size < numNodesToAllocate; attempts += 1) {\n      const nodeIdx = getRandomInt(0, nodes.length);\n      const dwnUrl = nodes[nodeIdx];\n\n      try {\n        const healthCheck = await fetch(`${dwnUrl}/health`);\n        if (healthCheck.ok) {\n          dwnUrls.add(dwnUrl);\n        }\n      } catch(e: unknown) {\n        // Ignore healthcheck failures and try the next node.\n      }\n    }\n\n    return Array.from(dwnUrls);\n  }\n\n  static #enqueueNextSync(syncManager: SyncManager, delay = 1_000) {\n    setTimeout(async () => {\n      try {\n        await syncManager.push();\n        await syncManager.pull();\n\n        return this.#enqueueNextSync(syncManager, delay);\n      } catch(e) {\n        console.error('Sync failed due to error: ', e);\n      }\n    }, delay);\n  }\n}", "import type { Web5Agent } from '@tbd54566975/web5-agent';\n\nexport class VcApi {\n  #agent: Web5Agent;\n  #connectedDid: string;\n\n  constructor(agent: Web5Agent, connectedDid: string) {\n    this.#agent = agent;\n    this.#connectedDid = connectedDid;\n  }\n\n  async create() {\n    // TODO: implement\n    throw new Error('Not implemented.');\n  }\n}", "import type { Web5Agent } from '@tbd54566975/web5-agent';\nimport type {\n  MessageReply,\n  ProtocolsConfigureDescriptor,\n  ProtocolsConfigureOptions,\n  ProtocolsQueryOptions,\n  RecordsDeleteOptions,\n  RecordsQueryOptions,\n  RecordsQueryReplyEntry,\n  RecordsReadOptions,\n  RecordsWriteMessage,\n  RecordsWriteOptions,\n  ProtocolsConfigureMessage\n} from '@tbd54566975/dwn-sdk-js';\n\nimport { DwnInterfaceName, DwnMethodName } from '@tbd54566975/dwn-sdk-js';\n\nimport { Record } from './record.js';\nimport { Protocol } from './protocol.js';\nimport { dataToBlob, isEmptyObject } from './utils.js';\n\nexport type ProtocolsConfigureRequest = {\n  message: Omit<ProtocolsConfigureOptions, 'authorizationSignatureInput'>;\n}\n\nexport type ProtocolsConfigureResponse = {\n  status: MessageReply['status'];\n  protocol?: Protocol;\n}\n\nexport type ProtocolsQueryReplyEntry = {\n  descriptor: ProtocolsConfigureDescriptor;\n};\n\nexport type ProtocolsQueryRequest = {\n  from?: string;\n  message: Omit<ProtocolsQueryOptions, 'authorizationSignatureInput'>\n}\n\nexport type ProtocolsQueryResponse = {\n  protocols: Protocol[];\n  status: MessageReply['status'];\n}\n\nexport type RecordsCreateRequest = RecordsWriteRequest;\n\nexport type RecordsCreateResponse = RecordsWriteResponse;\n\nexport type RecordsCreateFromRequest = {\n  author: string;\n  data: unknown;\n  message?: Omit<RecordsWriteOptions, 'authorizationSignatureInput'>;\n  record: Record;\n}\n\nexport type RecordsDeleteRequest = {\n  from?: string;\n  message: Omit<RecordsDeleteOptions, 'authorizationSignatureInput'>;\n}\n\nexport type RecordsDeleteResponse = {\n  status: MessageReply['status'];\n};\n\nexport type RecordsQueryRequest = {\n  /** The from property indicates the DID to query from and return results. */\n  from?: string;\n  message: Omit<RecordsQueryOptions, 'authorizationSignatureInput'>;\n}\n\nexport type RecordsQueryResponse = {\n  status: MessageReply['status'];\n  records?: Record[]\n};\n\nexport type RecordsReadRequest = {\n  /** The from property indicates the DID to read from and return results fro. */\n  from?: string;\n  message: Omit<RecordsReadOptions, 'authorizationSignatureInput'>;\n}\n\nexport type RecordsReadResponse = {\n  status: MessageReply['status'];\n  record: Record;\n};\n\nexport type RecordsWriteRequest = {\n  data: unknown;\n  message?: Omit<Partial<RecordsWriteOptions>, 'authorizationSignatureInput'>;\n  store?: boolean;\n}\n\nexport type RecordsWriteResponse = {\n  status: MessageReply['status'];\n  record?: Record\n};\n\n/**\n * TODO: Document class.\n */\nexport class DwnApi {\n  constructor(private web5Agent: Web5Agent, private connectedDid: string) {}\n\n  /**\n * TODO: Document namespace.\n */\n  get protocols() {\n    return {\n      /**\n       * TODO: Document method.\n       */\n      configure: async (request: ProtocolsConfigureRequest): Promise<ProtocolsConfigureResponse> => {\n        const agentResponse = await this.web5Agent.processDwnRequest({\n          target         : this.connectedDid,\n          author         : this.connectedDid,\n          messageOptions : request.message,\n          messageType    : DwnInterfaceName.Protocols + DwnMethodName.Configure\n        });\n\n        const { message, messageCid, reply: { status }} = agentResponse;\n        const response: ProtocolsConfigureResponse = { status };\n\n        if (status.code < 300) {\n          const metadata = { author: this.connectedDid, messageCid };\n          response.protocol = new Protocol(this.web5Agent, message as ProtocolsConfigureMessage, metadata);\n        }\n\n        return response;\n      },\n\n      /**\n       * TODO: Document method.\n       */\n      query: async (request: ProtocolsQueryRequest): Promise<ProtocolsQueryResponse> => {\n        const agentResponse = await this.web5Agent.processDwnRequest({\n          author         : this.connectedDid,\n          messageOptions : request.message,\n          messageType    : DwnInterfaceName.Protocols + DwnMethodName.Query,\n          target         : this.connectedDid\n        });\n\n        const { reply: { entries, status } } = agentResponse;\n        // const protocols = entries as ProtocolsQueryReplyEntry[];\n\n        const protocols = entries.map((entry: ProtocolsQueryReplyEntry) => {\n          const metadata = { author: this.connectedDid, };\n\n          return new Protocol(this.web5Agent, entry, metadata);\n        });\n\n        return { protocols, status };\n      }\n    };\n  }\n\n  /**\n   * TODO: Document namespace.\n   */\n  get records() {\n    return {\n      /**\n       * TODO: Document method.\n       */\n      create: async (request: RecordsCreateRequest): Promise<RecordsCreateResponse> => {\n        return this.records.write(request);\n      },\n\n      /**\n       * TODO: Document method.\n       */\n      createFrom: async (request: RecordsCreateFromRequest): Promise<RecordsWriteResponse> => {\n        const { author: inheritedAuthor, ...inheritedProperties } = request.record.toJSON();\n\n        // Remove target from inherited properties since target is being explicitly defined in method parameters.\n        delete inheritedProperties.target;\n\n\n        // If `data` is being updated then `dataCid` and `dataSize` must not be present.\n        if (request.data !== undefined) {\n          delete inheritedProperties.dataCid;\n          delete inheritedProperties.dataSize;\n        }\n\n        // If `published` is set to false, ensure that `datePublished` is undefined. Otherwise, DWN SDK's schema validation\n        // will throw an error if `published` is false but `datePublished` is set.\n        if (request.message?.published === false && inheritedProperties.datePublished !== undefined) {\n          delete inheritedProperties.datePublished;\n          delete inheritedProperties.published;\n        }\n\n        // If the request changes the `author` or message `descriptor` then the deterministic `recordId` will change.\n        // As a result, we will discard the `recordId` if either of these changes occur.\n        if (!isEmptyObject(request.message) || (request.author && request.author !== inheritedAuthor)) {\n          delete inheritedProperties.recordId;\n        }\n\n        return this.records.write({\n          data    : request.data,\n          message : {\n            ...inheritedProperties,\n            ...request.message,\n          },\n        });\n      },\n\n      /**\n       * TODO: Document method.\n       */\n      delete: async (request: RecordsDeleteRequest): Promise<RecordsDeleteResponse> => {\n        const agentRequest = {\n          author         : this.connectedDid,\n          messageOptions : request.message,\n          messageType    : DwnInterfaceName.Records + DwnMethodName.Delete,\n          target         : request.from || this.connectedDid\n        };\n\n        let agentResponse;\n\n        if (request.from) {\n          agentResponse = await this.web5Agent.sendDwnRequest(agentRequest);\n        } else {\n          agentResponse = await this.web5Agent.processDwnRequest(agentRequest);\n        }\n\n        //! TODO: (Frank -> Moe): This quirk is the result of how 4XX errors are being returned by `dwn-server`\n        //!                       When DWN SDK returns 404, agentResponse is { status: { code: 404 }} and that's it.\n        //!                       Need to decide how to resolve.\n        let status;\n        if (agentResponse.reply) {\n          ({ reply: { status } } = agentResponse);\n        } else {\n          ({ status } = agentResponse);\n        }\n\n        return { status };\n      },\n\n      /**\n       * TODO: Document method.\n       */\n      query: async (request: RecordsQueryRequest): Promise<RecordsQueryResponse> => {\n        const agentRequest = {\n          author         : this.connectedDid,\n          messageOptions : request.message,\n          messageType    : DwnInterfaceName.Records + DwnMethodName.Query,\n          target         : request.from || this.connectedDid\n        };\n\n        let agentResponse;\n\n        if (request.from) {\n          agentResponse = await this.web5Agent.sendDwnRequest(agentRequest);\n        } else {\n          agentResponse = await this.web5Agent.processDwnRequest(agentRequest);\n        }\n\n        const { reply: { entries, status } } = agentResponse;\n\n        const records = entries.map((entry: RecordsQueryReplyEntry) => {\n          const recordOptions = {\n            author : this.connectedDid,\n            target : this.connectedDid,\n            ...entry as RecordsWriteMessage\n          };\n          const record = new Record(this.web5Agent, recordOptions);\n          return record;\n        });\n\n        return { records, status };\n      },\n\n      /**\n       * TODO: Document method.\n       */\n      read: async (request: RecordsReadRequest): Promise<RecordsReadResponse> => {\n        const agentRequest = {\n          author         : this.connectedDid,\n          messageOptions : request.message,\n          messageType    : DwnInterfaceName.Records + DwnMethodName.Read,\n          target         : request.from || this.connectedDid\n        };\n\n        let agentResponse;\n\n        if (request.from) {\n          agentResponse = await this.web5Agent.sendDwnRequest(agentRequest);\n        } else {\n          agentResponse = await this.web5Agent.processDwnRequest(agentRequest);\n        }\n\n        //! TODO: (Frank -> Moe): This quirk is the result of how 4XX errors are being returned by `dwn-server`\n        //!                       When DWN SDK returns 404, agentResponse is { status: { code: 404 }} and that's it.\n        //!                       Need to decide how to resolve.\n        let responseRecord;\n        let status;\n        if (agentResponse.reply) {\n          ({ reply: { record: responseRecord, status } } = agentResponse);\n        } else {\n          ({ status } = agentResponse);\n        }\n\n        let record: Record;\n        if (200 <= status.code && status.code <= 299) {\n          const recordOptions = {\n            author : this.connectedDid,\n            target : this.connectedDid,\n            ...responseRecord,\n          };\n\n          record = new Record(this.web5Agent, recordOptions);\n        }\n\n        return { record, status };\n      },\n\n      /**\n       * TODO: Document method.\n       *\n       * As a convenience, the Record instance returned will cache a copy of the data if the\n       * data size, in bytes, is less than the DWN 'max data size allowed to be encoded'\n       * parameter of 10KB. This is done to maintain consistency with other DWN methods,\n       * like RecordsQuery, that include relatively small data payloads when returning\n       * RecordsWrite message properties. Regardless of data size, methods such as\n       * `record.data.stream()` will return the data when called even if it requires fetching\n       * from the DWN datastore.\n       */\n      write: async (request: RecordsWriteRequest): Promise<RecordsWriteResponse> => {\n        const messageOptions: Partial<RecordsWriteOptions> = {\n          ...request.message\n        };\n\n        const { dataBlob, dataFormat } = dataToBlob(request.data, messageOptions.dataFormat);\n        messageOptions.dataFormat = dataFormat;\n\n        const agentResponse = await this.web5Agent.processDwnRequest({\n          author      : this.connectedDid,\n          dataStream  : dataBlob,\n          messageOptions,\n          messageType : DwnInterfaceName.Records + DwnMethodName.Write,\n          store       : request.store,\n          target      : this.connectedDid\n        });\n\n        const { message, reply: { status } } = agentResponse;\n        const responseMessage = message as RecordsWriteMessage;\n\n        let record: Record;\n        if (200 <= status.code && status.code <= 299) {\n          const recordOptions = {\n            author      : this.connectedDid,\n            encodedData : dataBlob,\n            target      : this.connectedDid,\n            ...responseMessage,\n          };\n\n          record = new Record(this.web5Agent, recordOptions);\n        }\n\n        return { record, status };\n      },\n    };\n  }\n}", "import type { Readable } from 'readable-stream';\nimport type { Web5Agent } from '@tbd54566975/web5-agent';\nimport type { RecordsReadReply, RecordsWriteDescriptor, RecordsWriteMessage, RecordsWriteOptions } from '@tbd54566975/dwn-sdk-js';\n\nimport { ReadableWebToNodeStream } from 'readable-web-to-node-stream';\nimport { DataStream, DwnInterfaceName, DwnMethodName, Encoder } from '@tbd54566975/dwn-sdk-js';\n\nimport { dataToBlob } from './utils.js';\nimport type { RecordsDeleteResponse } from './dwn-api.js';\n\nexport type RecordOptions = RecordsWriteMessage & {\n  author: string;\n  target: string;\n  encodedData?: string | Blob;\n  data?: Readable | ReadableStream;\n};\n\nexport type RecordModel = RecordsWriteDescriptor & Omit<RecordsWriteMessage, 'descriptor' | 'recordId'> & {\n  author: string;\n  recordId?: string;\n  target: string;\n}\n\nexport type RecordUpdateOptions = {\n  data?: unknown;\n  dataCid?: RecordsWriteDescriptor['dataCid'];\n  dataSize?: RecordsWriteDescriptor['dataSize'];\n  dateModified?: RecordsWriteDescriptor['dateModified'];\n  datePublished?: RecordsWriteDescriptor['datePublished'];\n  published?: RecordsWriteDescriptor['published'];\n}\n\n/**\n   * TODO: Document class.\n   */\nexport class Record implements RecordModel {\n  // mutable properties\n  author: string;\n  target: string;\n  isDeleted = false;\n\n  #attestation?: RecordsWriteMessage['attestation'];\n  #contextId?: string;\n  #descriptor: RecordsWriteDescriptor;\n  #encodedData?: string | Blob | null;\n  #encryption?: RecordsWriteMessage['encryption'];\n  #readableStream?: Readable | Promise<Readable>;\n  #recordId: string;\n  #web5Agent: Web5Agent;\n\n  // Immutable DWN Record properties.\n  get attestation(): RecordsWriteMessage['attestation'] { return this.#attestation; }\n  get contextId() { return this.#contextId; }\n  get dataFormat() { return this.#descriptor.dataFormat; }\n  get dateCreated() { return this.#descriptor.dateCreated; }\n  get encryption(): RecordsWriteMessage['encryption'] { return this.#encryption; }\n  get id() { return this.#recordId; }\n  get interface() { return this.#descriptor.interface; }\n  get method() { return this.#descriptor.method; }\n  get parentId() { return this.#descriptor.parentId; }\n  get protocol() { return this.#descriptor.protocol; }\n  get protocolPath() { return this.#descriptor.protocolPath; }\n  get recipient() { return this.#descriptor.recipient; }\n  get schema() { return this.#descriptor.schema; }\n\n  // Mutable DWN Record properties.\n  get dataCid() { return this.#descriptor.dataCid; }\n  get dataSize() { return this.#descriptor.dataSize; }\n  get dateModified() { return this.#descriptor.dateModified; }\n  get datePublished() { return this.#descriptor.datePublished; }\n  get published() { return this.#descriptor.published; }\n\n  constructor(web5Agent: Web5Agent, options: RecordOptions) {\n    this.#web5Agent = web5Agent;\n\n    // Store the target and author DIDs that were used to create the message to use for subsequent reads, etc.\n    this.author = options.author;\n    this.target = options.target;\n\n    // RecordsWriteMessage properties.\n    this.#attestation = options.attestation;\n    this.#contextId = options.contextId;\n    this.#descriptor = options.descriptor;\n    this.#encryption = options.encryption;\n    this.#recordId = options.recordId;\n\n\n    // options.encodedData will either be a base64url encoded string (in the case of RecordsQuery)\n    // OR a Blob in the case of a RecordsWrite.\n    this.#encodedData = options.encodedData ?? null;\n\n    // If the record was created from a RecordsRead reply then it will have a `data` property.\n    if (options.data) {\n      this.#readableStream = Record.isReadableWebStream(options.data) ?\n        new ReadableWebToNodeStream(<ReadableStream>options.data) as Readable : options.data as Readable;\n    }\n  }\n\n  /**\n   * TODO: Document method.\n   */\n  get data() {\n    if (this.isDeleted) throw new Error('Operation failed: Attempted to access `data` of a record that has already been deleted.');\n\n    if (!this.#encodedData && !this.#readableStream) {\n      // `encodedData` will be set if the Record was instantiated by dwn.records.create()/write().\n      // `readableStream` will be set if Record was instantiated by dwn.records.read().\n      // If neither of the above are true, then the record must be fetched from the DWN.\n      this.#readableStream = this.#web5Agent.processDwnRequest({\n        author         : this.author,\n        messageOptions : { recordId: this.id },\n        messageType    : DwnInterfaceName.Records + DwnMethodName.Read,\n        target         : this.target,\n      })\n        .then(response => response.reply as RecordsReadReply)\n        .then(reply => reply.record.data as Readable)\n        .catch(error => { throw new Error(`Error encountered while attempting to read data: ${error.message}`); });\n    }\n\n    if (typeof this.#encodedData === 'string') {\n      // If `encodedData` is set, then it is expected that:\n      // type is Blob if the Record object was instantiated by dwn.records.create()/write().\n      // type is Base64 URL encoded string if the Record object was instantiated by dwn.records.query().\n      // If it is a string, we need to Base64 URL decode to bytes and instantiate a Blob.\n      const dataBytes = Encoder.base64UrlToBytes(this.#encodedData);\n      this.#encodedData = new Blob([dataBytes], { type: this.dataFormat });\n    }\n\n    // Explicitly cast #encodedData as a Blob since if non-null, it has been converted from string to Blob.\n    const dataBlob = this.#encodedData as Blob;\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this; // Capture the context of the `Record` instance.\n    const dataObj = {\n      async blob(): Promise<Blob> {\n        if (dataBlob) return dataBlob;\n        if (self.#readableStream) return new Blob([await this.stream().then(DataStream.toBytes)], { type: self.dataFormat });\n      },\n      async json() {\n        if (dataBlob) return this.text().then(JSON.parse);\n        if (self.#readableStream) return this.text().then(JSON.parse);\n        return null;\n      },\n      async text() {\n        if (dataBlob) return dataBlob.text();\n        if (self.#readableStream) return this.stream().then(DataStream.toBytes).then(Encoder.bytesToString);\n        return null;\n      },\n      async stream() {\n        if (dataBlob) return new ReadableWebToNodeStream(dataBlob.stream());\n        if (self.#readableStream) return self.#readableStream;\n        return null;\n      },\n      then(...callbacks) {\n        return this.stream().then(...callbacks);\n      },\n      catch(callback) {\n        return dataObj.then().catch(callback);\n      },\n    };\n    return dataObj;\n  }\n\n  /**\n   * TODO: Document method.\n   */\n  async delete(): Promise<RecordsDeleteResponse> {\n    if (this.isDeleted) throw new Error('Operation failed: Attempted to call `delete()` on a record that has already been deleted.');\n\n    // Attempt to delete the record from the DWN.\n    const agentResponse = await this.#web5Agent.processDwnRequest({\n      author         : this.author,\n      messageOptions : { recordId: this.id },\n      messageType    : DwnInterfaceName.Records + DwnMethodName.Delete,\n      target         : this.target,\n    });\n\n    const { reply: { status } } = agentResponse;\n\n    if (status.code === 202) {\n      // If the record was successfully deleted, mark the instance as deleted to prevent further modifications.\n      this.#setDeletedStatus(true);\n    }\n\n    return { status };\n  }\n\n  /**\n   * TODO: Document method.\n   */\n  async send(target: string): Promise<any> {\n    if (this.isDeleted) throw new Error('Operation failed: Attempted to call `send()` on a record that has already been deleted.');\n\n    const { reply: { status } } = await this.#web5Agent.sendDwnRequest({\n      messageType    : DwnInterfaceName.Records + DwnMethodName.Write,\n      author         : this.author,\n      dataStream     : await this.data.blob(),\n      target         : target,\n      messageOptions : this.toJSON(),\n    });\n\n    return { status };\n  }\n\n  /**\n   * TODO: Document method.\n   *\n   * Called by `JSON.stringify(...)` automatically.\n   */\n  toJSON(): RecordModel {\n    return {\n      attestation   : this.attestation,\n      author        : this.author,\n      contextId     : this.contextId,\n      dataCid       : this.dataCid,\n      dataFormat    : this.dataFormat,\n      dataSize      : this.dataSize,\n      dateCreated   : this.dateCreated,\n      dateModified  : this.dateModified,\n      datePublished : this.datePublished,\n      encryption    : this.encryption,\n      interface     : this.interface,\n      method        : this.method,\n      parentId      : this.parentId,\n      protocol      : this.protocol,\n      protocolPath  : this.protocolPath,\n      published     : this.published,\n      recipient     : this.recipient,\n      recordId      : this.id,\n      schema        : this.schema,\n      target        : this.target,\n    };\n  }\n\n  /**\n   * TODO: Document method.\n   *\n   * Called automatically in string concatenation, String() type conversion, and template literals.\n   */\n  toString() {\n    let str = `Record: {\\n`;\n    str += `  ID: ${this.id}\\n`;\n    str += this.contextId ? `  Context ID: ${this.contextId}\\n` : '';\n    str += this.protocol ? `  Protocol: ${this.protocol}\\n` : '';\n    str += this.schema ? `  Schema: ${this.schema}\\n` : '';\n    str += `  Data CID: ${this.dataCid}\\n`;\n    str += `  Data Format: ${this.dataFormat}\\n`;\n    str += `  Data Size: ${this.dataSize}\\n`;\n    str += `  Created: ${this.dateCreated}\\n`;\n    str += `  Modified: ${this.dateModified}\\n`;\n    str += `}`;\n    return str;\n  }\n\n  /**\n   * TODO: Document method.\n   */\n  async update(options: RecordUpdateOptions = {}) {\n    if (this.isDeleted) throw new Error('Operation failed: Attempted to call `update()` on a record that has already been deleted.');\n\n    // Begin assembling update message.\n    let updateMessage = { ...this.#descriptor, ...options } as Partial<RecordsWriteOptions>;\n\n    let dataBlob: Blob;\n    if (options.data !== undefined) {\n      // If `data` is being updated then `dataCid` and `dataSize` must be undefined and the `data` property is passed as\n      // a top-level property to `web5Agent.processDwnRequest()`.\n      delete updateMessage.dataCid;\n      delete updateMessage.dataSize;\n      delete updateMessage.data;\n\n      ({ dataBlob } = dataToBlob(options.data, updateMessage.dataFormat));\n    }\n\n    // Throw an error if an attempt is made to modify immutable properties. `data` has already been handled.\n    const mutableDescriptorProperties = new Set(['data', 'dataCid', 'dataSize', 'dateModified', 'datePublished', 'published']);\n    Record.#verifyPermittedMutation(Object.keys(options), mutableDescriptorProperties);\n\n    // If a new `dateModified` was not provided, remove it from the updateMessage to let the DWN SDK auto-fill.\n    // This is necessary because otherwise DWN SDK throws an Error 409 Conflict due to attempting to overwrite a record\n    // when the `dateModified` timestamps are identical.\n    if (options.dateModified === undefined) {\n      delete updateMessage.dateModified;\n    }\n\n    // If `published` is set to false, ensure that `datePublished` is undefined. Otherwise, DWN SDK's schema validation\n    // will throw an error if `published` is false but `datePublished` is set.\n    if (options.published === false && updateMessage.datePublished !== undefined) {\n      delete updateMessage.datePublished;\n    }\n\n    // Set the record ID and context ID, if any.\n    updateMessage.recordId = this.#recordId;\n    updateMessage.contextId = this.#contextId;\n\n    const messageOptions: Partial<RecordsWriteOptions> = {\n      ...updateMessage\n    };\n\n    const agentResponse = await this.#web5Agent.processDwnRequest({\n      author      : this.author,\n      dataStream  : dataBlob,\n      messageOptions,\n      messageType : DwnInterfaceName.Records + DwnMethodName.Write,\n      target      : this.target,\n    });\n\n    const { message, reply: { status } } = agentResponse;\n    const responseMessage = message as RecordsWriteMessage;\n\n    if (200 <= status.code && status.code <= 299) {\n      // Only update the local Record instance mutable properties if the record was successfully (over)written.\n      mutableDescriptorProperties.forEach(property => {\n        this.#descriptor[property] = responseMessage.descriptor[property];\n      });\n      // Only cache data if `dataSize` is less than DWN 'max data size allowed to be encoded'.\n      if (options.data !== undefined) {\n        this.#encodedData = dataBlob; // Clear `encodedData` in case it was previously set.\n      }\n    }\n\n    return { status };\n  }\n\n  /**\n   * TODO: Document method.\n   */\n  #setDeletedStatus(status: boolean): void {\n    this.isDeleted = status;\n  }\n\n  /**\n   * TODO: Document method.\n   */\n  static isReadableWebStream(stream) {\n    // TODO: Improve robustness of the check modeled after node:stream.\n    return typeof stream._read !== 'function';\n  }\n\n  /**\n   * TODO: Document method.\n   */\n  static #verifyPermittedMutation(propertiesToMutate: Iterable<string>, mutableDescriptorProperties: Set<string>) {\n    for (const property of propertiesToMutate) {\n      if (!mutableDescriptorProperties.has(property)) {\n        throw new Error(`${property} is an immutable property. Its value cannot be changed.`);\n      }\n    }\n  }\n}", "import { DwnConstant, Encoder } from '@tbd54566975/dwn-sdk-js';\n\nconst textDecoder = new TextDecoder();\n\n// TODO: Remove if this method is ever added to the DWN SDK Encoder class\nexport function base64UrlToString(base64urlString) {\n  const bytes = Encoder.base64UrlToBytes(base64urlString);\n  return Encoder.bytesToString(bytes);\n}\n\n// TODO: Remove if this method is ever added to the DWN SDK Encoder class\nexport function bytesToObject(bytes) {\n  const objectString = textDecoder.decode(bytes);\n  return JSON.parse(objectString);\n}\n\n/**\n * Checks if the provided data size is under the cache limit.\n * The cache limit is based on the maxDataSizeAllowedToBeEncoded defined in the DWN SDK.\n *\n * @export\n * @param {number} dataSize - The size of the data to be checked, in bytes.\n * @returns {boolean} True if the data size is less than or equal to the maximum allowed data size, false otherwise.\n *\n * @example\n * // Returns: true\n * isDataSizeUnderCacheLimit(5000);\n *\n * @example\n * // Returns: false\n * isDataSizeUnderCacheLimit(15000);\n */\nexport function isDataSizeUnderCacheLimit(dataSize: number): boolean {\n  return dataSize <= DwnConstant.maxDataSizeAllowedToBeEncoded;\n}\n\n/**\n * Set/detect the media type and return the data as bytes.\n */\nexport const dataToBlob = (data: any, dataFormat?: string) => {\n  let dataBlob: Blob;\n\n  // Check for Object or String, and if neither, assume bytes.\n  const detectedType = toType(data);\n  if (dataFormat === 'text/plain' || detectedType === 'string') {\n    dataBlob = new Blob([data], { type: 'text/plain' });\n  } else if (dataFormat === 'application/json' || detectedType === 'object') {\n    const dataBytes = Encoder.objectToBytes(data);\n    dataBlob = new Blob([dataBytes], { type: 'application/json' });\n  } else if (data instanceof Uint8Array || data instanceof ArrayBuffer) {\n    dataBlob = new Blob([data], { type: 'application/octet-stream' });\n  } else if (data instanceof Blob) {\n    dataBlob = data;\n  } else {\n    throw new Error('data type not supported.');\n  }\n\n  dataFormat = dataFormat || dataBlob.type || 'application/octet-stream';\n\n  return { dataBlob, dataFormat };\n};\n\nexport function isEmptyObject(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    return Object.keys(obj).length === 0;\n  }\n  return false;\n}\n\n/**\n * Simplistic initial implementation to check whether messages that are being routed\n * to process locally or be transported to a remote DWN are already signed.\n *\n * TODO: Consider whether cryptographic signature verification is warranted or if\n *       the naive check is sufficient given that DWNs already verify authenticity\n *       and integrity of every message.\n * @param {{}} message\n * @returns boolean\n */\nexport function isUnsignedMessage(message) {\n  return message?.message?.authorization ? false : true;\n}\n\nexport function objectValuesBase64UrlToBytes(obj) {\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, Encoder.base64UrlToBytes(value as string)]));\n}\n\nexport function objectValuesBytesToBase64Url(obj) {\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, Encoder.bytesToBase64Url(value as Uint8Array)]));\n}\n\nexport function parseJson(str) {\n  try {\n    return JSON.parse(str);\n  } catch {\n    return null;\n  }\n}\n\nexport function parseUrl(str) {\n  try {\n    return new URL(str);\n  } catch {\n    return null;\n  }\n}\n\nexport function pascalToKebabCase(str) {\n  return str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1-$2')\n    .toLowerCase();\n}\n\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n/**\n * Credit for toType() function:\n *   Angus Croll\n *   https://github.com/angus-c\n *   https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/\n */\nconst toType = (obj) => {\n  return ({}).toString.call(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n};", "import type { Web5Agent } from '@tbd54566975/web5-agent';\nimport type { ProtocolsConfigure } from '@tbd54566975/dwn-sdk-js';\n\n// TODO: export ProtocolsConfigureMessage from dwn-sdk-js\nexport type ProtocolsConfigureMessage = ProtocolsConfigure['message'];\ntype ProtocolMetadata = {\n  author: string;\n  messageCid?: string;\n};\n\nexport class Protocol {\n  #metadata: ProtocolMetadata;\n  #web5Agent: Web5Agent;\n  #protocolsConfigureMessage: ProtocolsConfigureMessage;\n\n  get definition() {\n    return this.#protocolsConfigureMessage.descriptor.definition;\n  }\n\n  constructor(web5Agent: Web5Agent, protocolsConfigureMessage: ProtocolsConfigureMessage, metadata: ProtocolMetadata) {\n    this.#metadata = metadata;\n    this.#web5Agent = web5Agent;\n    this.#protocolsConfigureMessage = protocolsConfigureMessage;\n  }\n\n  toJSON() {\n    return this.#protocolsConfigureMessage;\n  }\n\n  async send(target: string) {\n    const { reply } = await this.#web5Agent.sendDwnRequest({\n      messageType : 'ProtocolsConfigure',\n      author      : this.#metadata.author,\n      target      : target,\n      messageCid  : this.#metadata.messageCid\n    });\n\n    return { status: reply.status };\n  }\n}", "import type {\n  DidKeyOptions,\n  DidIonCreateOptions,\n  DidMethodApi,\n  DidMethodCreator,\n  DidMethodResolver,\n  DidResolverCache,\n  DidResolutionResult,\n  DidState\n} from '@tbd54566975/dids';\n\n\nimport { DidResolver } from '@tbd54566975/dids';\n\n// Map method names to option types\ntype CreateMethodOptions = {\n  ion: DidIonCreateOptions;\n  key: DidKeyOptions;\n};\n\n// A conditional type for inferring options based on the method name\ntype CreateOptions<M extends keyof CreateMethodOptions> = CreateMethodOptions[M];\n\nexport type DidApiOptions = {\n  didMethodApis: DidMethodApi[];\n  cache?: DidResolverCache;\n}\nexport class DidApi {\n  private didResolver: DidResolver;\n  private methodCreatorMap: Map<string, DidMethodCreator> = new Map();\n\n  /**\n   * returns the DID resolver created by this api. useful in scenarios where you want to pass around\n   * the same resolver so that you can leverage the resolver's cache\n   */\n  get resolver() {\n    return this.didResolver;\n  }\n\n  constructor(options: DidApiOptions) {\n    const { didMethodApis, cache } = options;\n\n    this.didResolver = new DidResolver({ methodResolvers: options.didMethodApis, cache });\n\n    for (let methodApi of didMethodApis) {\n      this.methodCreatorMap.set(methodApi.methodName, methodApi);\n    }\n  }\n\n  /**\n   * Creates a DID of the method provided\n   * @param method - the method of DID to create\n   * @param options - method-specific options\n   * @returns the created DID\n   */\n  create<M extends keyof CreateMethodOptions>(method: M, options?: CreateOptions<M>): Promise<DidState> {\n    const didMethodCreator = this.methodCreatorMap.get(method);\n    if (!didMethodCreator) {\n      throw new Error(`no creator available for ${method}`);\n    }\n\n    return didMethodCreator.create(options);\n  }\n\n  /**\n   * Resolves the provided DID\n   * @param did - the did to resolve\n   * @see {@link https://www.w3.org/TR/did-core/#did-resolution | DID Resolution}\n   * @returns DID Resolution Result\n   */\n  resolve(did: string): Promise<DidResolutionResult> {\n    return this.didResolver.resolve(did);\n  }\n\n  /**\n   * can be used to add different did method resolvers\n   * @param _resolver\n   */\n  addMethodResolver(_resolver: DidMethodResolver) {\n    throw new Error('not yet implemented');\n  }\n\n  /**\n   * can be used to add differed did method creators\n   * @param _creator\n   */\n  addMethodCreator(_creator: DidMethodCreator) {\n    throw new Error('not yet implemented');\n  }\n}", "import { Level } from 'level';\n\n// simple isomorphic key/value store\n// TODO: create KeyValueStore interface that this class implements\nexport class AppStorage {\n  private store: Level<string, string>;\n\n  constructor(location = 'data/app/storage') {\n    this.store = new Level(location);\n  }\n\n  async get(key: string): Promise<string | undefined> {\n    try {\n      return await this.store.get(key);\n    } catch(e: any) {\n      if (e.code === 'LEVEL_NOT_FOUND') {\n        return;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  set(key: string, value: string): Promise<void> {\n    return this.store.put(key, value);\n  }\n\n  async delete(key: string): Promise<void> {\n    return this.store.del(key);\n  }\n\n  async clear(): Promise<void> {\n    return this.store.clear();\n  }\n\n  async close(): Promise<void> {\n    return this.store.close();\n  }\n}", "import type { DidResolutionResult, DidResolverCache } from '@tbd54566975/dids';\n\nimport ms from 'ms';\nimport { Level } from 'level';\n\nexport type DidResolutionCacheOptions = {\n  location?: string;\n  ttl?: string;\n}\n\ntype CacheWrapper = {\n  ttlMillis: number;\n  value: DidResolutionResult;\n}\n\n/**\n * naive level-based cache for did resolution results. It just so happens that level aggressively keeps as much as it\n * can in memory when possible while also writing to the filesystem (in node runtime) and indexedDB (in browser runtime).\n * the persistent aspect is especially useful across page refreshes.\n */\nexport class DidResolutionCache implements DidResolverCache {\n  private cache: Level<string, string>;\n  private ttl: number;\n\n  static #defaultOptions = {\n    location : 'data/did-res-cache',\n    ttl      : '15m'\n  };\n\n  constructor(options: DidResolutionCacheOptions = {}) {\n    options = { ...DidResolutionCache.#defaultOptions, ...options };\n\n    this.cache = new Level(options.location!);\n    this.ttl = ms(options.ttl!);\n  }\n\n  async get(did: string): Promise<DidResolutionResult | void> {\n    try {\n      const str = await this.cache.get(did);\n      const cacheWrapper: CacheWrapper = JSON.parse(str);\n\n      if (Date.now() >= cacheWrapper.ttlMillis) {\n        // defer deletion to be called in the next tick of the js event loop\n        this.cache.nextTick(() => this.cache.del(did));\n\n        return;\n      } else {\n        return cacheWrapper.value;\n      }\n\n\n    } catch(e: any) {\n      // thrown when a key wasn't found\n      if (e.code === 'LEVEL_NOT_FOUND') {\n        return;\n      }\n\n      throw e;\n    }\n  }\n  set(did: string, value: DidResolutionResult): Promise<void> {\n    const cacheWrapper: CacheWrapper = { ttlMillis: Date.now() + this.ttl, value };\n    const str = JSON.stringify(cacheWrapper);\n\n    return this.cache.put(did, str);\n  }\n  delete(did: string): Promise<void> {\n    return this.cache.del(did);\n  }\n  clear(): Promise<void> {\n    return this.cache.clear();\n  }\n  close(): Promise<void> {\n    return this.cache.close();\n  }\n\n}\n"],
  "mappings": "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",
  "names": ["DwnInterfaceName", "DwnMethodName", "Encoder", "Encoder", "_web5Agent", "DwnInterfaceName", "DwnMethodName", "Level", "Level", "_connectedDid"]
}
