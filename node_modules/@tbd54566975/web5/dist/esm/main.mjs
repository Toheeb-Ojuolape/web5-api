var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/web5.ts
import { Dwn } from "@tbd54566975/dwn-sdk-js";
import { Web5UserAgent, ProfileApi, SyncApi } from "@tbd54566975/web5-user-agent";
import { DidIonApi, DidKeyApi, utils as didUtils } from "@tbd54566975/dids";

// src/vc-api.ts
var _agent, _connectedDid;
var VcApi = class {
  constructor(agent, connectedDid) {
    __privateAdd(this, _agent, void 0);
    __privateAdd(this, _connectedDid, void 0);
    __privateSet(this, _agent, agent);
    __privateSet(this, _connectedDid, connectedDid);
  }
  create() {
    return __async(this, null, function* () {
      throw new Error("Not implemented.");
    });
  }
};
_agent = new WeakMap();
_connectedDid = new WeakMap();

// src/dwn-api.ts
import { DwnInterfaceName as DwnInterfaceName2, DwnMethodName as DwnMethodName2 } from "@tbd54566975/dwn-sdk-js";

// src/record.ts
import { ReadableWebToNodeStream } from "readable-web-to-node-stream";
import { DataStream, DwnInterfaceName, DwnMethodName, Encoder as Encoder2 } from "@tbd54566975/dwn-sdk-js";

// src/utils.ts
import { DwnConstant, Encoder } from "@tbd54566975/dwn-sdk-js";
var textDecoder = new TextDecoder();
var dataToBlob = (data, dataFormat) => {
  let dataBlob;
  const detectedType = toType(data);
  if (dataFormat === "text/plain" || detectedType === "string") {
    dataBlob = new Blob([data], { type: "text/plain" });
  } else if (dataFormat === "application/json" || detectedType === "object") {
    const dataBytes = Encoder.objectToBytes(data);
    dataBlob = new Blob([dataBytes], { type: "application/json" });
  } else if (data instanceof Uint8Array || data instanceof ArrayBuffer) {
    dataBlob = new Blob([data], { type: "application/octet-stream" });
  } else if (data instanceof Blob) {
    dataBlob = data;
  } else {
    throw new Error("data type not supported.");
  }
  dataFormat = dataFormat || dataBlob.type || "application/octet-stream";
  return { dataBlob, dataFormat };
};
function isEmptyObject(obj) {
  if (typeof obj === "object" && obj !== null) {
    return Object.keys(obj).length === 0;
  }
  return false;
}
function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min;
}
var toType = (obj) => {
  return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
};

// src/record.ts
var _attestation, _contextId, _descriptor, _encodedData, _encryption, _readableStream, _recordId, _web5Agent, _setDeletedStatus, setDeletedStatus_fn, _verifyPermittedMutation, verifyPermittedMutation_fn;
var _Record = class {
  constructor(web5Agent, options) {
    /**
     * TODO: Document method.
     */
    __privateAdd(this, _setDeletedStatus);
    this.isDeleted = false;
    __privateAdd(this, _attestation, void 0);
    __privateAdd(this, _contextId, void 0);
    __privateAdd(this, _descriptor, void 0);
    __privateAdd(this, _encodedData, void 0);
    __privateAdd(this, _encryption, void 0);
    __privateAdd(this, _readableStream, void 0);
    __privateAdd(this, _recordId, void 0);
    __privateAdd(this, _web5Agent, void 0);
    var _a;
    __privateSet(this, _web5Agent, web5Agent);
    this.author = options.author;
    this.target = options.target;
    __privateSet(this, _attestation, options.attestation);
    __privateSet(this, _contextId, options.contextId);
    __privateSet(this, _descriptor, options.descriptor);
    __privateSet(this, _encryption, options.encryption);
    __privateSet(this, _recordId, options.recordId);
    __privateSet(this, _encodedData, (_a = options.encodedData) != null ? _a : null);
    if (options.data) {
      __privateSet(this, _readableStream, _Record.isReadableWebStream(options.data) ? new ReadableWebToNodeStream(options.data) : options.data);
    }
  }
  // Immutable DWN Record properties.
  get attestation() {
    return __privateGet(this, _attestation);
  }
  get contextId() {
    return __privateGet(this, _contextId);
  }
  get dataFormat() {
    return __privateGet(this, _descriptor).dataFormat;
  }
  get dateCreated() {
    return __privateGet(this, _descriptor).dateCreated;
  }
  get encryption() {
    return __privateGet(this, _encryption);
  }
  get id() {
    return __privateGet(this, _recordId);
  }
  get interface() {
    return __privateGet(this, _descriptor).interface;
  }
  get method() {
    return __privateGet(this, _descriptor).method;
  }
  get parentId() {
    return __privateGet(this, _descriptor).parentId;
  }
  get protocol() {
    return __privateGet(this, _descriptor).protocol;
  }
  get protocolPath() {
    return __privateGet(this, _descriptor).protocolPath;
  }
  get recipient() {
    return __privateGet(this, _descriptor).recipient;
  }
  get schema() {
    return __privateGet(this, _descriptor).schema;
  }
  // Mutable DWN Record properties.
  get dataCid() {
    return __privateGet(this, _descriptor).dataCid;
  }
  get dataSize() {
    return __privateGet(this, _descriptor).dataSize;
  }
  get dateModified() {
    return __privateGet(this, _descriptor).dateModified;
  }
  get datePublished() {
    return __privateGet(this, _descriptor).datePublished;
  }
  get published() {
    return __privateGet(this, _descriptor).published;
  }
  /**
   * TODO: Document method.
   */
  get data() {
    if (this.isDeleted)
      throw new Error("Operation failed: Attempted to access `data` of a record that has already been deleted.");
    if (!__privateGet(this, _encodedData) && !__privateGet(this, _readableStream)) {
      __privateSet(this, _readableStream, __privateGet(this, _web5Agent).processDwnRequest({
        author: this.author,
        messageOptions: { recordId: this.id },
        messageType: DwnInterfaceName.Records + DwnMethodName.Read,
        target: this.target
      }).then((response) => response.reply).then((reply) => reply.record.data).catch((error) => {
        throw new Error(`Error encountered while attempting to read data: ${error.message}`);
      }));
    }
    if (typeof __privateGet(this, _encodedData) === "string") {
      const dataBytes = Encoder2.base64UrlToBytes(__privateGet(this, _encodedData));
      __privateSet(this, _encodedData, new Blob([dataBytes], { type: this.dataFormat }));
    }
    const dataBlob = __privateGet(this, _encodedData);
    const self = this;
    const dataObj = {
      blob() {
        return __async(this, null, function* () {
          if (dataBlob)
            return dataBlob;
          if (__privateGet(self, _readableStream))
            return new Blob([yield this.stream().then(DataStream.toBytes)], { type: self.dataFormat });
        });
      },
      json() {
        return __async(this, null, function* () {
          if (dataBlob)
            return this.text().then(JSON.parse);
          if (__privateGet(self, _readableStream))
            return this.text().then(JSON.parse);
          return null;
        });
      },
      text() {
        return __async(this, null, function* () {
          if (dataBlob)
            return dataBlob.text();
          if (__privateGet(self, _readableStream))
            return this.stream().then(DataStream.toBytes).then(Encoder2.bytesToString);
          return null;
        });
      },
      stream() {
        return __async(this, null, function* () {
          if (dataBlob)
            return new ReadableWebToNodeStream(dataBlob.stream());
          if (__privateGet(self, _readableStream))
            return __privateGet(self, _readableStream);
          return null;
        });
      },
      then(...callbacks) {
        return this.stream().then(...callbacks);
      },
      catch(callback) {
        return dataObj.then().catch(callback);
      }
    };
    return dataObj;
  }
  /**
   * TODO: Document method.
   */
  delete() {
    return __async(this, null, function* () {
      if (this.isDeleted)
        throw new Error("Operation failed: Attempted to call `delete()` on a record that has already been deleted.");
      const agentResponse = yield __privateGet(this, _web5Agent).processDwnRequest({
        author: this.author,
        messageOptions: { recordId: this.id },
        messageType: DwnInterfaceName.Records + DwnMethodName.Delete,
        target: this.target
      });
      const { reply: { status } } = agentResponse;
      if (status.code === 202) {
        __privateMethod(this, _setDeletedStatus, setDeletedStatus_fn).call(this, true);
      }
      return { status };
    });
  }
  /**
   * TODO: Document method.
   */
  send(target) {
    return __async(this, null, function* () {
      if (this.isDeleted)
        throw new Error("Operation failed: Attempted to call `send()` on a record that has already been deleted.");
      const { reply: { status } } = yield __privateGet(this, _web5Agent).sendDwnRequest({
        messageType: DwnInterfaceName.Records + DwnMethodName.Write,
        author: this.author,
        dataStream: yield this.data.blob(),
        target,
        messageOptions: this.toJSON()
      });
      return { status };
    });
  }
  /**
   * TODO: Document method.
   *
   * Called by `JSON.stringify(...)` automatically.
   */
  toJSON() {
    return {
      attestation: this.attestation,
      author: this.author,
      contextId: this.contextId,
      dataCid: this.dataCid,
      dataFormat: this.dataFormat,
      dataSize: this.dataSize,
      dateCreated: this.dateCreated,
      dateModified: this.dateModified,
      datePublished: this.datePublished,
      encryption: this.encryption,
      interface: this.interface,
      method: this.method,
      parentId: this.parentId,
      protocol: this.protocol,
      protocolPath: this.protocolPath,
      published: this.published,
      recipient: this.recipient,
      recordId: this.id,
      schema: this.schema,
      target: this.target
    };
  }
  /**
   * TODO: Document method.
   *
   * Called automatically in string concatenation, String() type conversion, and template literals.
   */
  toString() {
    let str = `Record: {
`;
    str += `  ID: ${this.id}
`;
    str += this.contextId ? `  Context ID: ${this.contextId}
` : "";
    str += this.protocol ? `  Protocol: ${this.protocol}
` : "";
    str += this.schema ? `  Schema: ${this.schema}
` : "";
    str += `  Data CID: ${this.dataCid}
`;
    str += `  Data Format: ${this.dataFormat}
`;
    str += `  Data Size: ${this.dataSize}
`;
    str += `  Created: ${this.dateCreated}
`;
    str += `  Modified: ${this.dateModified}
`;
    str += `}`;
    return str;
  }
  /**
   * TODO: Document method.
   */
  update() {
    return __async(this, arguments, function* (options = {}) {
      var _a;
      if (this.isDeleted)
        throw new Error("Operation failed: Attempted to call `update()` on a record that has already been deleted.");
      let updateMessage = __spreadValues(__spreadValues({}, __privateGet(this, _descriptor)), options);
      let dataBlob;
      if (options.data !== void 0) {
        delete updateMessage.dataCid;
        delete updateMessage.dataSize;
        delete updateMessage.data;
        ({ dataBlob } = dataToBlob(options.data, updateMessage.dataFormat));
      }
      const mutableDescriptorProperties = /* @__PURE__ */ new Set(["data", "dataCid", "dataSize", "dateModified", "datePublished", "published"]);
      __privateMethod(_a = _Record, _verifyPermittedMutation, verifyPermittedMutation_fn).call(_a, Object.keys(options), mutableDescriptorProperties);
      if (options.dateModified === void 0) {
        delete updateMessage.dateModified;
      }
      if (options.published === false && updateMessage.datePublished !== void 0) {
        delete updateMessage.datePublished;
      }
      updateMessage.recordId = __privateGet(this, _recordId);
      updateMessage.contextId = __privateGet(this, _contextId);
      const messageOptions = __spreadValues({}, updateMessage);
      const agentResponse = yield __privateGet(this, _web5Agent).processDwnRequest({
        author: this.author,
        dataStream: dataBlob,
        messageOptions,
        messageType: DwnInterfaceName.Records + DwnMethodName.Write,
        target: this.target
      });
      const { message, reply: { status } } = agentResponse;
      const responseMessage = message;
      if (200 <= status.code && status.code <= 299) {
        mutableDescriptorProperties.forEach((property) => {
          __privateGet(this, _descriptor)[property] = responseMessage.descriptor[property];
        });
        if (options.data !== void 0) {
          __privateSet(this, _encodedData, dataBlob);
        }
      }
      return { status };
    });
  }
  /**
   * TODO: Document method.
   */
  static isReadableWebStream(stream) {
    return typeof stream._read !== "function";
  }
};
var Record = _Record;
_attestation = new WeakMap();
_contextId = new WeakMap();
_descriptor = new WeakMap();
_encodedData = new WeakMap();
_encryption = new WeakMap();
_readableStream = new WeakMap();
_recordId = new WeakMap();
_web5Agent = new WeakMap();
_setDeletedStatus = new WeakSet();
setDeletedStatus_fn = function(status) {
  this.isDeleted = status;
};
_verifyPermittedMutation = new WeakSet();
verifyPermittedMutation_fn = function(propertiesToMutate, mutableDescriptorProperties) {
  for (const property of propertiesToMutate) {
    if (!mutableDescriptorProperties.has(property)) {
      throw new Error(`${property} is an immutable property. Its value cannot be changed.`);
    }
  }
};
/**
 * TODO: Document method.
 */
__privateAdd(Record, _verifyPermittedMutation);

// src/protocol.ts
var _metadata, _web5Agent2, _protocolsConfigureMessage;
var Protocol = class {
  constructor(web5Agent, protocolsConfigureMessage, metadata) {
    __privateAdd(this, _metadata, void 0);
    __privateAdd(this, _web5Agent2, void 0);
    __privateAdd(this, _protocolsConfigureMessage, void 0);
    __privateSet(this, _metadata, metadata);
    __privateSet(this, _web5Agent2, web5Agent);
    __privateSet(this, _protocolsConfigureMessage, protocolsConfigureMessage);
  }
  get definition() {
    return __privateGet(this, _protocolsConfigureMessage).descriptor.definition;
  }
  toJSON() {
    return __privateGet(this, _protocolsConfigureMessage);
  }
  send(target) {
    return __async(this, null, function* () {
      const { reply } = yield __privateGet(this, _web5Agent2).sendDwnRequest({
        messageType: "ProtocolsConfigure",
        author: __privateGet(this, _metadata).author,
        target,
        messageCid: __privateGet(this, _metadata).messageCid
      });
      return { status: reply.status };
    });
  }
};
_metadata = new WeakMap();
_web5Agent2 = new WeakMap();
_protocolsConfigureMessage = new WeakMap();

// src/dwn-api.ts
var DwnApi = class {
  constructor(web5Agent, connectedDid) {
    this.web5Agent = web5Agent;
    this.connectedDid = connectedDid;
  }
  /**
  * TODO: Document namespace.
  */
  get protocols() {
    return {
      /**
       * TODO: Document method.
       */
      configure: (request) => __async(this, null, function* () {
        const agentResponse = yield this.web5Agent.processDwnRequest({
          target: this.connectedDid,
          author: this.connectedDid,
          messageOptions: request.message,
          messageType: DwnInterfaceName2.Protocols + DwnMethodName2.Configure
        });
        const { message, messageCid, reply: { status } } = agentResponse;
        const response = { status };
        if (status.code < 300) {
          const metadata = { author: this.connectedDid, messageCid };
          response.protocol = new Protocol(this.web5Agent, message, metadata);
        }
        return response;
      }),
      /**
       * TODO: Document method.
       */
      query: (request) => __async(this, null, function* () {
        const agentResponse = yield this.web5Agent.processDwnRequest({
          author: this.connectedDid,
          messageOptions: request.message,
          messageType: DwnInterfaceName2.Protocols + DwnMethodName2.Query,
          target: this.connectedDid
        });
        const { reply: { entries, status } } = agentResponse;
        const protocols = entries.map((entry) => {
          const metadata = { author: this.connectedDid };
          return new Protocol(this.web5Agent, entry, metadata);
        });
        return { protocols, status };
      })
    };
  }
  /**
   * TODO: Document namespace.
   */
  get records() {
    return {
      /**
       * TODO: Document method.
       */
      create: (request) => __async(this, null, function* () {
        return this.records.write(request);
      }),
      /**
       * TODO: Document method.
       */
      createFrom: (request) => __async(this, null, function* () {
        var _b;
        const _a = request.record.toJSON(), { author: inheritedAuthor } = _a, inheritedProperties = __objRest(_a, ["author"]);
        delete inheritedProperties.target;
        if (request.data !== void 0) {
          delete inheritedProperties.dataCid;
          delete inheritedProperties.dataSize;
        }
        if (((_b = request.message) == null ? void 0 : _b.published) === false && inheritedProperties.datePublished !== void 0) {
          delete inheritedProperties.datePublished;
          delete inheritedProperties.published;
        }
        if (!isEmptyObject(request.message) || request.author && request.author !== inheritedAuthor) {
          delete inheritedProperties.recordId;
        }
        return this.records.write({
          data: request.data,
          message: __spreadValues(__spreadValues({}, inheritedProperties), request.message)
        });
      }),
      /**
       * TODO: Document method.
       */
      delete: (request) => __async(this, null, function* () {
        const agentRequest = {
          author: this.connectedDid,
          messageOptions: request.message,
          messageType: DwnInterfaceName2.Records + DwnMethodName2.Delete,
          target: request.from || this.connectedDid
        };
        let agentResponse;
        if (request.from) {
          agentResponse = yield this.web5Agent.sendDwnRequest(agentRequest);
        } else {
          agentResponse = yield this.web5Agent.processDwnRequest(agentRequest);
        }
        let status;
        if (agentResponse.reply) {
          ({ reply: { status } } = agentResponse);
        } else {
          ({ status } = agentResponse);
        }
        return { status };
      }),
      /**
       * TODO: Document method.
       */
      query: (request) => __async(this, null, function* () {
        const agentRequest = {
          author: this.connectedDid,
          messageOptions: request.message,
          messageType: DwnInterfaceName2.Records + DwnMethodName2.Query,
          target: request.from || this.connectedDid
        };
        let agentResponse;
        if (request.from) {
          agentResponse = yield this.web5Agent.sendDwnRequest(agentRequest);
        } else {
          agentResponse = yield this.web5Agent.processDwnRequest(agentRequest);
        }
        const { reply: { entries, status } } = agentResponse;
        const records = entries.map((entry) => {
          const recordOptions = __spreadValues({
            author: this.connectedDid,
            target: this.connectedDid
          }, entry);
          const record = new Record(this.web5Agent, recordOptions);
          return record;
        });
        return { records, status };
      }),
      /**
       * TODO: Document method.
       */
      read: (request) => __async(this, null, function* () {
        const agentRequest = {
          author: this.connectedDid,
          messageOptions: request.message,
          messageType: DwnInterfaceName2.Records + DwnMethodName2.Read,
          target: request.from || this.connectedDid
        };
        let agentResponse;
        if (request.from) {
          agentResponse = yield this.web5Agent.sendDwnRequest(agentRequest);
        } else {
          agentResponse = yield this.web5Agent.processDwnRequest(agentRequest);
        }
        let responseRecord;
        let status;
        if (agentResponse.reply) {
          ({ reply: { record: responseRecord, status } } = agentResponse);
        } else {
          ({ status } = agentResponse);
        }
        let record;
        if (200 <= status.code && status.code <= 299) {
          const recordOptions = __spreadValues({
            author: this.connectedDid,
            target: this.connectedDid
          }, responseRecord);
          record = new Record(this.web5Agent, recordOptions);
        }
        return { record, status };
      }),
      /**
       * TODO: Document method.
       *
       * As a convenience, the Record instance returned will cache a copy of the data if the
       * data size, in bytes, is less than the DWN 'max data size allowed to be encoded'
       * parameter of 10KB. This is done to maintain consistency with other DWN methods,
       * like RecordsQuery, that include relatively small data payloads when returning
       * RecordsWrite message properties. Regardless of data size, methods such as
       * `record.data.stream()` will return the data when called even if it requires fetching
       * from the DWN datastore.
       */
      write: (request) => __async(this, null, function* () {
        const messageOptions = __spreadValues({}, request.message);
        const { dataBlob, dataFormat } = dataToBlob(request.data, messageOptions.dataFormat);
        messageOptions.dataFormat = dataFormat;
        const agentResponse = yield this.web5Agent.processDwnRequest({
          author: this.connectedDid,
          dataStream: dataBlob,
          messageOptions,
          messageType: DwnInterfaceName2.Records + DwnMethodName2.Write,
          store: request.store,
          target: this.connectedDid
        });
        const { message, reply: { status } } = agentResponse;
        const responseMessage = message;
        let record;
        if (200 <= status.code && status.code <= 299) {
          const recordOptions = __spreadValues({
            author: this.connectedDid,
            encodedData: dataBlob,
            target: this.connectedDid
          }, responseMessage);
          record = new Record(this.web5Agent, recordOptions);
        }
        return { record, status };
      })
    };
  }
};

// src/did-api.ts
import { DidResolver } from "@tbd54566975/dids";
var DidApi = class {
  constructor(options) {
    this.methodCreatorMap = /* @__PURE__ */ new Map();
    const { didMethodApis, cache } = options;
    this.didResolver = new DidResolver({ methodResolvers: options.didMethodApis, cache });
    for (let methodApi of didMethodApis) {
      this.methodCreatorMap.set(methodApi.methodName, methodApi);
    }
  }
  /**
   * returns the DID resolver created by this api. useful in scenarios where you want to pass around
   * the same resolver so that you can leverage the resolver's cache
   */
  get resolver() {
    return this.didResolver;
  }
  /**
   * Creates a DID of the method provided
   * @param method - the method of DID to create
   * @param options - method-specific options
   * @returns the created DID
   */
  create(method, options) {
    const didMethodCreator = this.methodCreatorMap.get(method);
    if (!didMethodCreator) {
      throw new Error(`no creator available for ${method}`);
    }
    return didMethodCreator.create(options);
  }
  /**
   * Resolves the provided DID
   * @param did - the did to resolve
   * @see {@link https://www.w3.org/TR/did-core/#did-resolution | DID Resolution}
   * @returns DID Resolution Result
   */
  resolve(did) {
    return this.didResolver.resolve(did);
  }
  /**
   * can be used to add different did method resolvers
   * @param _resolver
   */
  addMethodResolver(_resolver) {
    throw new Error("not yet implemented");
  }
  /**
   * can be used to add differed did method creators
   * @param _creator
   */
  addMethodCreator(_creator) {
    throw new Error("not yet implemented");
  }
};

// src/app-storage.ts
import { Level } from "level";
var AppStorage = class {
  constructor(location = "data/app/storage") {
    this.store = new Level(location);
  }
  get(key) {
    return __async(this, null, function* () {
      try {
        return yield this.store.get(key);
      } catch (e) {
        if (e.code === "LEVEL_NOT_FOUND") {
          return;
        } else {
          throw e;
        }
      }
    });
  }
  set(key, value) {
    return this.store.put(key, value);
  }
  delete(key) {
    return __async(this, null, function* () {
      return this.store.del(key);
    });
  }
  clear() {
    return __async(this, null, function* () {
      return this.store.clear();
    });
  }
  close() {
    return __async(this, null, function* () {
      return this.store.close();
    });
  }
};

// src/did-resolution-cache.ts
import ms from "ms";
import { Level as Level2 } from "level";
var _defaultOptions;
var _DidResolutionCache = class {
  constructor(options = {}) {
    options = __spreadValues(__spreadValues({}, __privateGet(_DidResolutionCache, _defaultOptions)), options);
    this.cache = new Level2(options.location);
    this.ttl = ms(options.ttl);
  }
  get(did) {
    return __async(this, null, function* () {
      try {
        const str = yield this.cache.get(did);
        const cacheWrapper = JSON.parse(str);
        if (Date.now() >= cacheWrapper.ttlMillis) {
          this.cache.nextTick(() => this.cache.del(did));
          return;
        } else {
          return cacheWrapper.value;
        }
      } catch (e) {
        if (e.code === "LEVEL_NOT_FOUND") {
          return;
        }
        throw e;
      }
    });
  }
  set(did, value) {
    const cacheWrapper = { ttlMillis: Date.now() + this.ttl, value };
    const str = JSON.stringify(cacheWrapper);
    return this.cache.put(did, str);
  }
  delete(did) {
    return this.cache.del(did);
  }
  clear() {
    return this.cache.clear();
  }
  close() {
    return this.cache.close();
  }
};
var DidResolutionCache = _DidResolutionCache;
_defaultOptions = new WeakMap();
__privateAdd(DidResolutionCache, _defaultOptions, {
  location: "data/did-res-cache",
  ttl: "15m"
});

// src/web5.ts
var _connectedDid2, _enqueueNextSync, enqueueNextSync_fn;
var _Web5 = class {
  constructor(options) {
    __privateAdd(this, _connectedDid2, void 0);
    __privateSet(this, _connectedDid2, options.connectedDid);
    this.dwn = new DwnApi(options.web5Agent, __privateGet(this, _connectedDid2));
    this.vc = new VcApi(options.web5Agent, __privateGet(this, _connectedDid2));
    this.appStorage || (this.appStorage = new AppStorage());
  }
  /**
   * DID functionality (e.g. creating and resolving DIDs)
   */
  get did() {
    return _Web5.did;
  }
  /**
   * Connects to a {@link Web5Agent}. defaults to creating an embedded {@link Web5UserAgent} if one isn't provided
   * @param options - optional overrides
   * @returns
   */
  static connect() {
    return __async(this, arguments, function* (options = {}) {
      var _a, _b, _c;
      const appStorage = new AppStorage();
      const cachedAppDidState = yield appStorage.get(_Web5.APP_DID_KEY);
      let appDidState;
      if (cachedAppDidState) {
        appDidState = JSON.parse(cachedAppDidState);
      } else {
        appDidState = yield this.did.create("key");
        appStorage.set(_Web5.APP_DID_KEY, JSON.stringify(appDidState));
      }
      const profileApi = new ProfileApi();
      let [profile] = yield profileApi.listProfiles();
      (_a = options.didMethodApis) != null ? _a : options.didMethodApis = [];
      _Web5.did = new DidApi({
        didMethodApis: [new DidIonApi(), new DidKeyApi(), ...options.didMethodApis],
        cache: options.didResolutionCache || new DidResolutionCache()
      });
      const dwn = yield Dwn.create();
      const syncManager = new SyncApi({
        profileManager: profileApi,
        didResolver: _Web5.did.resolver,
        // share the same resolver to share the same underlying cache
        dwn
      });
      if (!profile) {
        const dwnUrls = ((_b = options.techPreview) == null ? void 0 : _b.dwnEndpoints) || (yield _Web5.getTechPreviewDwnEndpoints());
        const ionCreateOptions = yield DidIonApi.generateDwnConfiguration(dwnUrls);
        const defaultProfileDid = yield this.did.create("ion", ionCreateOptions);
        profile = yield profileApi.createProfile({
          name: appDidState.id,
          did: defaultProfileDid,
          connections: [appDidState.id]
        });
        yield syncManager.registerProfile(profile.did.id);
      }
      const agent = yield Web5UserAgent.create({
        profileManager: profileApi,
        didResolver: _Web5.did.resolver,
        // share the same resolver to share the same underlying cache
        syncManager,
        dwn
      });
      const connectedDid = profile.did.id;
      const web5 = new _Web5({ appStorage, web5Agent: agent, connectedDid });
      __privateMethod(_c = _Web5, _enqueueNextSync, enqueueNextSync_fn).call(_c, syncManager, 1e3);
      return { web5, did: connectedDid };
    });
  }
  /**
   * Dynamically selects up to 2 DWN endpoints that are provided
   * by default during the Tech Preview period.
   */
  static getTechPreviewDwnEndpoints() {
    return __async(this, null, function* () {
      let response;
      try {
        response = yield fetch("https://dwn.tbddev.org/.well-known/did.json");
        if (!response.ok) {
          throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
        }
      } catch (e) {
        console.warn("failed to get tech preview dwn endpoints:", e.message);
        return [];
      }
      const didDoc = yield response.json();
      const [service] = didUtils.getServices(didDoc, { id: "#dwn", type: "DecentralizedWebNode" });
      const { nodes } = service.serviceEndpoint;
      const dwnUrls = /* @__PURE__ */ new Set();
      const numNodesToAllocate = Math.min(nodes.length, 2);
      for (let attempts = 0; attempts < nodes.length && dwnUrls.size < numNodesToAllocate; attempts += 1) {
        const nodeIdx = getRandomInt(0, nodes.length);
        const dwnUrl = nodes[nodeIdx];
        try {
          const healthCheck = yield fetch(`${dwnUrl}/health`);
          if (healthCheck.ok) {
            dwnUrls.add(dwnUrl);
          }
        } catch (e) {
        }
      }
      return Array.from(dwnUrls);
    });
  }
};
var Web5 = _Web5;
_connectedDid2 = new WeakMap();
_enqueueNextSync = new WeakSet();
enqueueNextSync_fn = function(syncManager, delay = 1e3) {
  setTimeout(() => __async(this, null, function* () {
    try {
      yield syncManager.push();
      yield syncManager.pull();
      return __privateMethod(this, _enqueueNextSync, enqueueNextSync_fn).call(this, syncManager, delay);
    } catch (e) {
      console.error("Sync failed due to error: ", e);
    }
  }), delay);
};
__privateAdd(Web5, _enqueueNextSync);
/**
 * Statically available DID functionality. can be used to create and resolve DIDs without calling {@link connect}.
 * By default, can create and resolve `did:key` and `did:ion`. DID resolution results are not cached unless `connect`
 * is called
 */
Web5.did = new DidApi({
  didMethodApis: [new DidIonApi(), new DidKeyApi()]
});
Web5.APP_DID_KEY = "WEB5_APP_DID";
export {
  Web5
};
//! TODO: (Frank -> Moe): This quirk is the result of how 4XX errors are being returned by `dwn-server`
//!                       When DWN SDK returns 404, agentResponse is { status: { code: 404 }} and that's it.
//!                       Need to decide how to resolve.
//# sourceMappingURL=main.mjs.map
