import type { SignatureInput } from '../jose/jws/general/types.js';
import type { BaseMessage, Descriptor, TimestampedMessage } from './types.js';
import type { GeneralJws } from '../jose/jws/general/types.js';
export declare enum DwnInterfaceName {
    Events = "Events",
    Hooks = "Hooks",
    Messages = "Messages",
    Permissions = "Permissions",
    Protocols = "Protocols",
    Records = "Records"
}
export declare enum DwnMethodName {
    Configure = "Configure",
    Get = "Get",
    Grant = "Grant",
    Query = "Query",
    Read = "Read",
    Request = "Request",
    Write = "Write",
    Delete = "Delete"
}
export declare abstract class Message<M extends BaseMessage> {
    readonly message: M;
    readonly authorizationPayload: any;
    readonly author: string | undefined;
    constructor(message: M);
    /**
     * Called by `JSON.stringify(...)` automatically.
     */
    toJSON(): BaseMessage;
    /**
     * Validates the given message against the corresponding JSON schema.
     * @throws {Error} if fails validation.
     */
    static validateJsonSchema(rawMessage: any): void;
    /**
     * Gets the DID of the author of the given message, returned `undefined` if message is not signed.
     */
    static getAuthor(message: BaseMessage): string | undefined;
    /**
     * Gets the CID of the given message.
     */
    static getCid(message: BaseMessage): Promise<string>;
    /**
     * Compares message CID in lexicographical order according to the spec.
     * @returns 1 if `a` is larger than `b`; -1 if `a` is smaller/older than `b`; 0 otherwise (same message)
     */
    static compareCid(a: BaseMessage, b: BaseMessage): Promise<number>;
    /**
     * Compares the CID of two messages.
     * @returns `true` if `a` is newer than `b`; `false` otherwise
     */
    static isCidLarger(a: BaseMessage, b: BaseMessage): Promise<boolean>;
    /**
     * @returns message with the largest CID in the array using lexicographical compare. `undefined` if given array is empty.
     */
    static getMessageWithLargestCid(messages: BaseMessage[]): Promise<BaseMessage | undefined>;
    /**
     * Signs over the CID of provided `descriptor`. The output is used as an `authorization` property.
     * @param signatureInput - the signature material to use (e.g. key and header data)
     * @returns General JWS signature used as an `authorization` property.
     */
    static signAsAuthorization(descriptor: Descriptor, signatureInput: SignatureInput): Promise<GeneralJws>;
    /**
     * @returns newest message in the array. `undefined` if given array is empty.
     */
    static getNewestMessage(messages: TimestampedMessage[]): Promise<TimestampedMessage | undefined>;
    /**
     * Checks if first message is newer than second message.
     * @returns `true` if `a` is newer than `b`; `false` otherwise
     */
    static isNewer(a: TimestampedMessage, b: TimestampedMessage): Promise<boolean>;
    /**
     * Checks if first message is older than second message.
     * @returns `true` if `a` is older than `b`; `false` otherwise
     */
    static isOlder(a: TimestampedMessage, b: TimestampedMessage): Promise<boolean>;
    /**
     * Compares the `dateModified` of the given messages with a fallback to message CID according to the spec.
     * @returns 1 if `a` is larger/newer than `b`; -1 if `a` is smaller/older than `b`; 0 otherwise (same age)
     */
    static compareModifiedTime(a: TimestampedMessage, b: TimestampedMessage): Promise<number>;
}
//# sourceMappingURL=message.d.ts.map