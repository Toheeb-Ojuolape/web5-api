import type { BaseMessage } from '../../../core/types.js';
import type { KeyDerivationScheme } from '../../../index.js';
import type { MessageStore } from '../../../store/message-store.js';
import type { PublicJwk } from '../../../jose/types.js';
import type { EncryptionProperty, RecordsWriteDescriptor, RecordsWriteMessage, UnsignedRecordsWriteMessage } from '../types.js';
import type { GeneralJws, SignatureInput } from '../../../jose/jws/general/types.js';
import { EncryptionAlgorithm } from '../../../utils/encryption.js';
import { Message } from '../../../core/message.js';
export declare type RecordsWriteOptions = {
    recipient?: string;
    protocol?: string;
    protocolPath?: string;
    contextId?: string;
    schema?: string;
    recordId?: string;
    parentId?: string;
    data?: Uint8Array;
    dataCid?: string;
    dataSize?: number;
    dateCreated?: string;
    dateModified?: string;
    published?: boolean;
    datePublished?: string;
    dataFormat: string;
    authorizationSignatureInput: SignatureInput;
    attestationSignatureInputs?: SignatureInput[];
    encryptionInput?: EncryptionInput;
};
/**
 * Input that describes how data is encrypted as spec-ed in TP18 (https://github.com/TBD54566975/technical-proposals/pull/6).
 */
export declare type EncryptionInput = {
    /**
     * Algorithm used for encrypting the Data. Uses {EncryptionAlgorithm.Aes256Ctr} if not given.
     */
    algorithm?: EncryptionAlgorithm;
    /**
     * Initialization vector used for encrypting the data.
     */
    initializationVector: Uint8Array;
    /**
     * Symmetric key used to encrypt the data.
     */
    key: Uint8Array;
    /**
     * Array of input that specifies how the symmetric key is encrypted.
     * Each entry in the array will result in a unique ciphertext of the symmetric key.
     */
    keyEncryptionInputs: KeyEncryptionInput[];
};
/**
 * Input that specifies how a symmetric key is encrypted.
 */
export declare type KeyEncryptionInput = {
    /**
     * Key derivation scheme to derive the descendant public key to encrypt the symmetric key.
     */
    derivationScheme: KeyDerivationScheme;
    /**
     * Fully qualified ID of root public key used derive the descendant public key to encrypt the symmetric key.
     * (e.g. did:example:abc#encryption-key-id)
     */
    publicKeyId: string;
    /**
     * Root public key used derive the descendant public key to encrypt the symmetric key.
     */
    publicKey: PublicJwk;
    /**
     * Algorithm used for encrypting the symmetric key. Uses {EncryptionAlgorithm.EciesSecp256k1} if not given.
     */
    algorithm?: EncryptionAlgorithm;
};
export declare type CreateFromOptions = {
    unsignedRecordsWriteMessage: UnsignedRecordsWriteMessage;
    data?: Uint8Array;
    published?: boolean;
    dateModified?: string;
    datePublished?: string;
    authorizationSignatureInput: SignatureInput;
    attestationSignatureInputs?: SignatureInput[];
    encryptionInput?: EncryptionInput;
};
export declare class RecordsWrite extends Message<RecordsWriteMessage> {
    readonly attesters: string[];
    private constructor();
    static parse(message: RecordsWriteMessage): Promise<RecordsWrite>;
    /**
     * Creates a RecordsWrite message.
     * @param options.recordId If `undefined`, will be auto-filled as a originating message as convenience for developer.
     * @param options.data Data used to compute the `dataCid`, must be the encrypted data bytes if `options.encryptionInput` is given.
     *                     Must specify `options.dataCid` if `undefined`.
     * @param options.dataCid CID of the data that is already stored in the DWN. Must specify `options.data` if `undefined`.
     * @param options.dataSize Size of data in number of bytes. Must be defined if `options.dataCid` is defined; must be `undefined` otherwise.
     * @param options.dateCreated If `undefined`, it will be auto-filled with current time.
     * @param options.dateModified If `undefined`, it will be auto-filled with current time.
     */
    static create(options: RecordsWriteOptions): Promise<RecordsWrite>;
    /**
     * Convenience method that creates a message by:
     * 1. Copying over immutable properties from the given unsigned message
     * 2. Copying over mutable properties that are not overwritten from the given unsigned message
     * 3. Replace the mutable properties that are given new value
     * @param options.unsignedRecordsWriteMessage Unsigned message that the new RecordsWrite will be based from.
     * @param options.dateModified The new date the record is modified. If not given, current time will be used .
     * @param options.data The new data or the record. If not given, data from given message will be used.
     * @param options.published The new published state. If not given, then will be set to `true` if {options.dateModified} is given;
     * else the state from given message will be used.
     * @param options.publishedDate The new date the record is modified. If not given, then:
     * - will not be set if the record will be unpublished as the result of this RecordsWrite; else
     * - will be set to the same published date as the given message if it wss already published; else
     * - will be set to current time (because this is a toggle from unpublished to published)
     */
    static createFrom(options: CreateFromOptions): Promise<RecordsWrite>;
    authorize(tenant: string, messageStore: MessageStore): Promise<void>;
    /**
     * Validates the integrity of the RecordsWrite message assuming the message passed basic schema validation.
     * There is opportunity to integrate better with `validateSchema(...)`
     */
    private validateIntegrity;
    /**
     * Validates the structural integrity of the `attestation` property.
     * NOTE: signature is not verified.
     */
    private static validateAttestationIntegrity;
    /**
     * Computes the deterministic Entry ID of this message.
     */
    getEntryId(): Promise<string>;
    /**
     * Computes the deterministic Entry ID of this message.
     */
    static getEntryId(author: string | undefined, descriptor: RecordsWriteDescriptor): Promise<string>;
    /**
     * Checks if the given message is the initial entry of a record.
     */
    isInitialWrite(): Promise<boolean>;
    /**
     * Checks if the given message is the initial entry of a record.
     */
    static isInitialWrite(message: BaseMessage): Promise<boolean>;
    /**
     * Creates the `encryption` property if encryption input is given. Else `undefined` is returned.
     */
    private static createEncryptionProperty;
    /**
     * Creates the `attestation` property of a RecordsWrite message if given signature inputs; returns `undefined` otherwise.
     */
    static createAttestation(descriptorCid: string, signatureInputs?: SignatureInput[]): Promise<GeneralJws | undefined>;
    /**
     * Creates the `authorization` property of a RecordsWrite message.
     */
    static createAuthorization(recordId: string, contextId: string | undefined, descriptorCid: string, attestation: GeneralJws | undefined, encryption: EncryptionProperty | undefined, signatureInput: SignatureInput): Promise<GeneralJws>;
    /**
     * Gets the initial write from the given list or record write.
     */
    static getInitialWrite(messages: BaseMessage[]): Promise<RecordsWriteMessage>;
    /**
     * Verifies that immutable properties of the two given messages are identical.
     * @throws {Error} if immutable properties between two RecordsWrite message
     */
    static verifyEqualityOfImmutableProperties(existingWriteMessage: RecordsWriteMessage, newMessage: RecordsWriteMessage): boolean;
    /**
     * Gets the DID of the author of the given message.
     */
    static getAttesters(message: RecordsWriteMessage): string[];
}
//# sourceMappingURL=records-write.d.ts.map