import type { DerivedPrivateJwk } from './hd-key.js';
import type { PublicJwk } from '../jose/types.js';
import type { Readable } from 'readable-stream';
import type { RecordsWriteDescriptor, UnsignedRecordsWriteMessage } from '../interfaces/records/types.js';
import { KeyDerivationScheme } from './hd-key.js';
/**
 * Class containing useful utilities related to the Records interface.
 */
export declare class Records {
    /**
     * Decrypts the encrypted data in a message reply using the given ancestor private key.
     * @param ancestorPrivateKey Any ancestor private key in the key derivation path.
     */
    static decrypt(recordsWrite: UnsignedRecordsWriteMessage, ancestorPrivateKey: DerivedPrivateJwk, cipherStream: Readable): Promise<Readable>;
    /**
     * Constructs full key derivation path using the specified scheme.
     */
    static constructKeyDerivationPath(keyDerivationScheme: KeyDerivationScheme, recordId: string, contextId: string | undefined, descriptor: RecordsWriteDescriptor): string[];
    /**
     * Constructs the full key derivation path using `dataFormats` scheme.
     */
    private static constructKeyDerivationPathUsingDataFormatsScheme;
    /**
     * Constructs the full key derivation path using `protocols` scheme.
     */
    private static constructKeyDerivationPathUsingProtocolsScheme;
    /**
     * Constructs the full key derivation path using `schemas` scheme.
     */
    private static constructKeyDerivationPathUsingSchemasScheme;
    /**
     * Derives a descendant public key given an ancestor public key.
     * NOTE: right now only `ECIES-ES256K` algorithm is supported for asymmetric encryption,
     *       so we will assume that's the algorithm without additional switch/if statements
     */
    static deriveLeafPublicKey(rootPublicKey: PublicJwk, fullDescendantDerivationPath: string[]): Promise<Uint8Array>;
    /**
     * Derives a descendant private key given an ancestor private key.
     * NOTE: right now only `ECIES-ES256K` algorithm is supported for asymmetric encryption,
     *       so we will assume that's the algorithm without additional switch/if statements
     */
    static deriveLeafPrivateKey(ancestorPrivateKey: DerivedPrivateJwk, fullDescendantDerivationPath: string[]): Promise<Uint8Array>;
    /**
     * Validates that ancestor derivation path matches the descendant derivation path completely.
     * @throws {DwnError} with `DwnErrorCode.RecordsInvalidAncestorKeyDerivationSegment` if fails validation.
     */
    static validateAncestorKeyAndDescentKeyDerivationPathsMatch(ancestorKeyDerivationPath: string[], descendantKeyDerivationPath: string[]): void;
}
//# sourceMappingURL=records.d.ts.map