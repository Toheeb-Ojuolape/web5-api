var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { flatten } from '../utils/object.js';
import { createLevelDatabase, LevelWrapper } from './level-wrapper.js';
/**
 * A LevelDB implementation for indexing the messages stored in the DWN.
 */
export class IndexLevel {
    constructor(config) {
        this.config = Object.assign({ createLevelDatabase }, config);
        this.db = new LevelWrapper(Object.assign(Object.assign({}, this.config), { valueEncoding: 'utf8' }));
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.db.open();
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.db.close();
        });
    }
    put(id, entry, options) {
        return __awaiter(this, void 0, void 0, function* () {
            entry = flatten(entry);
            const ops = [];
            const prefixes = [];
            for (const property in entry) {
                const value = entry[property];
                const prefix = this.join(property, this.encodeValue(value));
                ops.push({ type: 'put', key: this.join(prefix, id), value: id });
                prefixes.push(prefix);
            }
            ops.push({ type: 'put', key: `__${id}__prefixes`, value: JSON.stringify(prefixes) });
            return this.db.batch(ops, options);
        });
    }
    query(filter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const requiredProperties = new Set();
            const missingPropertiesForID = {};
            const promises = [];
            const matchedIDs = [];
            function checkMatches(property, promise) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    promises.push(promise);
                    for (const [_, id] of yield promise) {
                        (_a = missingPropertiesForID[id]) !== null && _a !== void 0 ? _a : (missingPropertiesForID[id] = new Set([...requiredProperties]));
                        missingPropertiesForID[id].delete(property);
                        if (missingPropertiesForID[id].size === 0) {
                            matchedIDs.push(id);
                        }
                    }
                });
            }
            for (const propertyName in filter) {
                const propertyFilter = filter[propertyName];
                if (typeof propertyFilter === 'object' && propertyFilter !== null) {
                    if (Array.isArray(propertyFilter)) {
                        for (const propertyValue of new Set(propertyFilter)) {
                            checkMatches(propertyName, this.findExactMatches(propertyName, propertyValue, options));
                        }
                    }
                    else {
                        checkMatches(propertyName, this.findRangeMatches(propertyName, propertyFilter, options));
                    }
                }
                else {
                    checkMatches(propertyName, this.findExactMatches(propertyName, propertyFilter, options));
                }
                requiredProperties.add(propertyName);
            }
            yield Promise.all(promises);
            return matchedIDs;
        });
    }
    delete(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const prefixes = yield this.db.get(`__${id}__prefixes`, options);
            if (!prefixes) {
                return;
            }
            const ops = [];
            for (const prefix of JSON.parse(prefixes)) {
                ops.push({ type: 'del', key: this.join(prefix, id) });
            }
            ops.push({ type: 'del', key: `__${id}__prefixes` });
            return this.db.batch(ops, options);
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.db.clear();
        });
    }
    findExactMatches(propertyName, propertyValue, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const propertyKey = this.join(propertyName, this.encodeValue(propertyValue));
            const iteratorOptions = {
                gt: propertyKey
            };
            return this.findMatches(propertyKey, iteratorOptions, options);
        });
    }
    findRangeMatches(propertyName, range, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const propertyKey = this.join(propertyName);
            const iteratorOptions = {};
            for (const comparator in range) {
                iteratorOptions[comparator] = this.join(propertyName, this.encodeValue(range[comparator]));
            }
            const matches = yield this.findMatches(propertyKey, iteratorOptions, options);
            if ('lte' in range) {
                // When using `lte` we must also query for an exact match due to how we're encoding values.
                // For example, `{ lte: 'foo' }` would not match `'foo\x02bar'`.
                for (const [key, value] of yield this.findExactMatches(propertyName, range.lte, options)) {
                    matches.set(key, value);
                }
            }
            return matches;
        });
    }
    findMatches(propertyName, iteratorOptions, options) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Since we will stop iterating if we encounter entries that do not start with the `propertyName`, we need to always start from the upper bound.
            // For example, `{ lte: 'b' }` would immediately stop if the data was `[ 'a', 'ab', 'b' ]` since `'a'` does not start with `'b'`.
            if (('lt' in iteratorOptions || 'lte' in iteratorOptions) && !('gt' in iteratorOptions || 'gte' in iteratorOptions)) {
                iteratorOptions.reverse = true;
            }
            const matches = new Map;
            try {
                for (var _b = __asyncValues(this.db.iterator(iteratorOptions, options)), _c; _c = yield _b.next(), !_c.done;) {
                    const [key, value] = _c.value;
                    if (!key.startsWith(propertyName)) {
                        break;
                    }
                    matches.set(key, value);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return matches;
        });
    }
    encodeValue(value) {
        if (typeof value === 'string') {
            // We can't just `JSON.stringify` as that'll affect the sort order of strings.
            // For example, `'\x00'` becomes `'\\u0000'`.
            return `"${value}"`;
        }
        return String(value);
    }
    join(...values) {
        return values.join(`\x00`);
    }
    dump() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            console.group('db');
            yield ((_b = (_a = this.db)['dump']) === null || _b === void 0 ? void 0 : _b.call(_a));
            console.groupEnd();
        });
    }
}
//# sourceMappingURL=index-level.js.map