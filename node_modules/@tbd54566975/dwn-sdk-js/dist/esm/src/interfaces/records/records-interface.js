var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { constructRecordsWriteIndexes } from './handlers/records-write.js';
import { Message } from '../../core/message.js';
import { RecordsWrite } from './messages/records-write.js';
import { StorageController } from '../../store/storage-controller.js';
/**
 * Deletes all messages in `existingMessages` that are older than the `comparedToMessage` in the given tenant,
 * but keep the initial write write for future processing by ensuring its `isLatestBaseState` index is "false".
 */
export function deleteAllOlderMessagesButKeepInitialWrite(tenant, existingMessages, comparedToMessage, messageStore, dataStore, eventLog) {
    return __awaiter(this, void 0, void 0, function* () {
        const deletedMessageCids = [];
        // NOTE: under normal operation, there should only be at most two existing records per `recordId` (initial + a potential subsequent write/delete),
        // but the DWN may crash before `delete()` is called below, so we use a loop as a tactic to clean up lingering data as needed
        for (const message of existingMessages) {
            const messageIsOld = yield Message.isOlder(message, comparedToMessage);
            if (messageIsOld) {
                // the easiest implementation here is delete each old messages
                // and re-create it with the right index (isLatestBaseState = 'false') if the message is the initial write,
                // but there is room for better/more efficient implementation here
                yield StorageController.delete(messageStore, dataStore, tenant, message);
                // if the existing message is the initial write
                // we actually need to keep it BUT, need to ensure the message is no longer marked as the latest state
                const existingMessageIsInitialWrite = yield RecordsWrite.isInitialWrite(message);
                if (existingMessageIsInitialWrite) {
                    const existingRecordsWrite = yield RecordsWrite.parse(message);
                    const isLatestBaseState = false;
                    const indexes = yield constructRecordsWriteIndexes(existingRecordsWrite, isLatestBaseState);
                    yield messageStore.put(tenant, message, indexes);
                }
                else {
                    const messageCid = yield Message.getCid(message);
                    deletedMessageCids.push(messageCid);
                }
            }
            yield eventLog.deleteEventsByCid(tenant, deletedMessageCids);
        }
    });
}
//# sourceMappingURL=records-interface.js.map