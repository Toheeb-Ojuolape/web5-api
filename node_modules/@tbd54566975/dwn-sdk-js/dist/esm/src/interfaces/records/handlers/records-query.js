var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { authenticate } from '../../../core/auth.js';
import { lexicographicalCompare } from '../../../utils/string.js';
import { MessageReply } from '../../../core/message-reply.js';
import { StorageController } from '../../../store/storage-controller.js';
import { DateSort, RecordsQuery } from '../messages/records-query.js';
import { DwnInterfaceName, DwnMethodName } from '../../../core/message.js';
export class RecordsQueryHandler {
    constructor(didResolver, messageStore, dataStore) {
        this.didResolver = didResolver;
        this.messageStore = messageStore;
        this.dataStore = dataStore;
    }
    handle({ tenant, message }) {
        return __awaiter(this, void 0, void 0, function* () {
            let recordsQuery;
            try {
                recordsQuery = yield RecordsQuery.parse(message);
            }
            catch (e) {
                return MessageReply.fromError(e, 400);
            }
            try {
                yield authenticate(message.authorization, this.didResolver);
                yield recordsQuery.authorize(tenant);
            }
            catch (e) {
                return MessageReply.fromError(e, 401);
            }
            let records;
            if (recordsQuery.author === tenant) {
                records = yield this.fetchRecordsAsOwner(tenant, recordsQuery);
            }
            else {
                records = yield this.fetchRecordsAsNonOwner(tenant, recordsQuery);
            }
            // sort if `dataSort` is specified
            if (recordsQuery.message.descriptor.dateSort) {
                records = yield sortRecords(records, recordsQuery.message.descriptor.dateSort);
            }
            // strip away `authorization` property for each record before responding
            const entries = [];
            for (const record of records) {
                const { authorization: _ } = record, objectWithRemainingProperties = __rest(record, ["authorization"]); // a trick to stripping away `authorization`
                entries.push(objectWithRemainingProperties);
            }
            return new MessageReply({
                status: { code: 200, detail: 'OK' },
                entries
            });
        });
    }
    /**
     * Fetches the records as the owner of the DWN with no additional filtering.
     */
    fetchRecordsAsOwner(tenant, recordsQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            // fetch all published records matching the query
            const filter = Object.assign(Object.assign({}, RecordsQuery.convertFilter(recordsQuery.message.descriptor.filter)), { interface: DwnInterfaceName.Records, method: DwnMethodName.Write, isLatestBaseState: true });
            const records = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter);
            return records;
        });
    }
    /**
     * Fetches the records as a non-owner, return only:
     * 1. published records; and
     * 2. unpublished records intended for the query author (where `recipient` is the query author)
     */
    fetchRecordsAsNonOwner(tenant, recordsQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            const publishedRecords = yield this.fetchPublishedRecords(tenant, recordsQuery);
            const unpublishedRecordsForQueryAuthor = yield this.fetchUnpublishedRecordsForQueryAuthor(tenant, recordsQuery);
            const unpublishedRecordsByAuthor = yield this.fetchUnpublishedRecordsByAuthor(tenant, recordsQuery);
            const records = [...publishedRecords, ...unpublishedRecordsForQueryAuthor, ...unpublishedRecordsByAuthor];
            return records;
        });
    }
    /**
     * Fetches only published records.
     */
    fetchPublishedRecords(tenant, recordsQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            // fetch all published records matching the query
            const filter = Object.assign(Object.assign({}, RecordsQuery.convertFilter(recordsQuery.message.descriptor.filter)), { interface: DwnInterfaceName.Records, method: DwnMethodName.Write, published: true, isLatestBaseState: true });
            const publishedRecords = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter);
            return publishedRecords;
        });
    }
    /**
     * Fetches only unpublished records that are intended for the query author (where `recipient` is the author).
     */
    fetchUnpublishedRecordsForQueryAuthor(tenant, recordsQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            // include records where recipient is query author
            const filter = Object.assign(Object.assign({}, RecordsQuery.convertFilter(recordsQuery.message.descriptor.filter)), { interface: DwnInterfaceName.Records, method: DwnMethodName.Write, 
                // TODO: `recordsQuery.author` cannot be undefined until #299 is implemented (https://github.com/TBD54566975/dwn-sdk-js/issues/299)
                recipient: recordsQuery.author, isLatestBaseState: true, published: false });
            const unpublishedRecordsForQueryAuthor = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter);
            return unpublishedRecordsForQueryAuthor;
        });
    }
    /**
     * Fetches only unpublished records where the author is the same as the query author.
     */
    fetchUnpublishedRecordsByAuthor(tenant, recordsQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            // include records where author is the same as the query author
            const filter = Object.assign(Object.assign({}, RecordsQuery.convertFilter(recordsQuery.message.descriptor.filter)), { 
                // TODO: `recordsQuery.author` cannot be undefined until #299 is implemented (https://github.com/TBD54566975/dwn-sdk-js/issues/299)
                author: recordsQuery.author, interface: DwnInterfaceName.Records, method: DwnMethodName.Write, isLatestBaseState: true, published: false });
            const unpublishedRecordsForQueryAuthor = yield StorageController.query(this.messageStore, this.dataStore, tenant, filter);
            return unpublishedRecordsForQueryAuthor;
        });
    }
}
/**
 * Sorts the given records. There are 4 options for dateSort:
 * 1. createdAscending - Sort in ascending order based on when the message was created
 * 2. createdDescending - Sort in descending order based on when the message was created
 * 3. publishedAscending - If the message is published, sort in asc based on publish date
 * 4. publishedDescending - If the message is published, sort in desc based on publish date
 *
 * If sorting is based on date published, records that are not published are filtered out.
 * @param messages - Messages to be sorted if dateSort is present
 * @param dateSort - Sorting scheme
 * @returns Sorted Messages
 */
function sortRecords(messages, dateSort) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (dateSort) {
            case DateSort.CreatedAscending:
                return messages.sort((a, b) => lexicographicalCompare(a.descriptor.dateCreated, b.descriptor.dateCreated));
            case DateSort.CreatedDescending:
                return messages.sort((a, b) => lexicographicalCompare(b.descriptor.dateCreated, a.descriptor.dateCreated));
            case DateSort.PublishedAscending:
                return messages
                    .filter(m => m.descriptor.published)
                    .sort((a, b) => lexicographicalCompare(a.descriptor.datePublished, b.descriptor.datePublished));
            case DateSort.PublishedDescending:
                return messages
                    .filter(m => m.descriptor.published)
                    .sort((a, b) => lexicographicalCompare(b.descriptor.datePublished, a.descriptor.datePublished));
        }
    });
}
//# sourceMappingURL=records-query.js.map