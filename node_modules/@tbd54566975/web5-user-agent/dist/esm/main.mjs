var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => {
  it = obj[Symbol.asyncIterator];
  method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((resolve, reject, done) => {
    arg = fn.call(obj, arg);
    done = arg.done;
    return Promise.resolve(arg.value).then((value) => resolve({ value, done }), reject);
  }));
  return it ? it.call(obj) : (obj = obj[Symbol.iterator](), it = {}, method("next"), method("return"), it);
};

// src/web5-user-agent.ts
import {
  DataStream
} from "@tbd54566975/dwn-sdk-js";
import {
  Cid,
  Encoder,
  Message
} from "@tbd54566975/dwn-sdk-js";
import { DidResolver, DidIonApi, DidKeyApi, utils as didUtils } from "@tbd54566975/dids";
import {
  Dwn,
  EventsGet,
  RecordsRead,
  MessagesGet,
  RecordsWrite,
  RecordsQuery,
  RecordsDelete,
  DwnMethodName,
  ProtocolsQuery,
  DwnInterfaceName,
  ProtocolsConfigure
} from "@tbd54566975/dwn-sdk-js";

// src/profile-store.ts
import { Level as Level2 } from "level";

// src/profile-index.ts
import { Level } from "level";
import flat from "flat";
var { flatten } = flat;
var ProfileIndex = class {
  constructor(location = "data/agent/profiles-index") {
    this.location = location;
    this.level = new Level(location);
  }
  delete(id) {
    return __async(this, null, function* () {
      const ops = [];
      let keyPrefixes = yield this.level.get(`__${id}__meta`);
      if (!keyPrefixes) {
        return;
      }
      keyPrefixes = keyPrefixes.split("@");
      for (let keyPrefix of keyPrefixes) {
        const op = { type: "del", key: `${keyPrefix}~${id}` };
        ops.push(op);
      }
      ops.push({ type: "del", key: `__${id}__meta` });
      yield this.level.batch(ops);
    });
  }
  put(record) {
    return __async(this, null, function* () {
      const flattenedRecord = flatten(record);
      let { id } = flattenedRecord;
      let keyPrefixes = [];
      const ops = [];
      for (let property in flattenedRecord) {
        if (property === "id") {
          continue;
        }
        const propVal = flattenedRecord[property];
        const keyPrefix = `${property}~${propVal}`;
        const key = `${keyPrefix}~${id}`;
        ops.push({ type: "put", key, value: id });
        keyPrefixes.push(keyPrefix);
      }
      ops.push({ type: "put", key: `__${id}__meta`, value: keyPrefixes.join("@") });
      yield this.level.batch(ops);
    });
  }
  query(filter) {
    return __async(this, null, function* () {
      const matches = {};
      const promises = [];
      for (let propertyName in filter) {
        const propertyValue = filter[propertyName];
        if (typeof propertyValue === "object" && propertyValue !== null) {
          if (Array.isArray(propertyValue)) {
            for (let value of propertyValue) {
              const promise = this.buildTermQuery(propertyName, value, matches);
              promises.push(promise);
            }
          } else {
            const promise = this.buildRangeQuery(propertyName, propertyValue, matches);
            promises.push(promise);
          }
        } else {
          const promise = this.buildTermQuery(propertyName, propertyValue, matches);
          promises.push(promise);
        }
      }
      const numFilters = Object.keys(filter).length;
      const docIds = [];
      yield Promise.all(promises);
      for (let docId in matches) {
        if (matches[docId] === numFilters) {
          docIds.push(docId);
        }
      }
      return docIds;
    });
  }
  buildTermQuery(propertyName, propertyValue, matches) {
    return __async(this, null, function* () {
      const key = `${propertyName}~${propertyValue}`;
      const iteratorOptions = {
        gt: `${key}~`
      };
      try {
        for (var iter = __forAwait(this.level.iterator(iteratorOptions)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          let doc = temp.value;
          const [k, val] = doc;
          if (!k.includes(key)) {
            break;
          }
          if (val in matches) {
            matches[val] += 1;
          } else {
            matches[val] = 1;
          }
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  buildRangeQuery(propertyName, range, matches) {
    return __async(this, null, function* () {
      const key = `${propertyName}`;
      const iteratorOptions = {};
      for (let inequality in range) {
        iteratorOptions[inequality] = `${propertyName}~${range[inequality]}`;
      }
      try {
        for (var iter = __forAwait(this.level.iterator(iteratorOptions)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          let doc = temp.value;
          const [k, val] = doc;
          if (!k.includes(key)) {
            break;
          }
          if (val in matches) {
            matches[val] += 1;
          } else {
            matches[val] = 1;
          }
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  clear() {
    return __async(this, null, function* () {
      this.level.clear();
    });
  }
  close() {
    return __async(this, null, function* () {
      return this.level.close();
    });
  }
};

// src/profile-store.ts
var _ProfileStore = class {
  constructor(options = {}) {
    options = __spreadValues(__spreadValues({}, _ProfileStore._defaultOptions), options);
    this.db = new Level2(options.location);
    this.index = new ProfileIndex(options.indexLocation);
  }
  put(entry) {
    return __async(this, null, function* () {
      const key = this.generateKey(entry.id);
      const value = JSON.stringify(entry);
      yield this.db.put(key, value);
      yield this.index.put(entry);
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const key = this.generateKey(id);
      try {
        const value = yield this.db.get(key);
        return JSON.parse(value);
      } catch (e) {
        if (e.code === "LEVEL_NOT_FOUND") {
          return void 0;
        }
      }
    });
  }
  query(filter) {
    return __async(this, null, function* () {
      const results = yield this.index.query(filter);
      const profiles = [];
      const serializedProfiles = yield this.db.getMany(results);
      for (let serializedProfile of serializedProfiles) {
        profiles.push(JSON.parse(serializedProfile));
      }
      return profiles;
    });
  }
  all() {
    return __async(this, null, function* () {
      const serializedProfiles = yield this.db.values().all();
      const profiles = [];
      for (let serializedProfile of serializedProfiles) {
        profiles.push(JSON.parse(serializedProfile));
      }
      return profiles;
    });
  }
  delete() {
    return __async(this, null, function* () {
      throw new Error("Method not implemented.");
    });
  }
  clear() {
    return __async(this, null, function* () {
      yield this.index.clear();
      yield this.db.clear();
      return;
    });
  }
  close() {
    return __async(this, null, function* () {
      yield this.index.close();
      yield this.db.close();
      return;
    });
  }
  generateKey(id) {
    return `PROFILE_${id}`;
  }
};
var ProfileStore = _ProfileStore;
ProfileStore._defaultOptions = {
  location: "data/agent/profiles",
  indexLocation: "data/agent/profiles-index"
};

// src/profile-api.ts
var ProfileApi = class {
  constructor(store) {
    this.store = store || (store = new ProfileStore());
  }
  createProfile(options) {
    return __async(this, null, function* () {
      var _a;
      if (!options.did && !options.didMethod) {
        throw new Error("must provide did or didMethod");
      }
      const profile = {
        name: options.name,
        icon: options.icon,
        dateCreated: new Date()
      };
      if (options.did) {
        profile.did = options.did;
      } else {
      }
      profile.id = (_a = options.did) == null ? void 0 : _a.id;
      yield this.store.put(profile);
      return profile;
    });
  }
  getProfile(id) {
    return this.store.get(id);
  }
  // TODO: discuss whether we want to rename this to getProfiles instead
  listProfiles() {
    return this.store.all();
  }
};

// src/dwn-rpc-client.ts
import { v4 as uuidv4 } from "uuid";
import { createJsonRpcRequest, parseJson } from "@tbd54566975/web5-agent";
var _transportClients;
var DwnRpcClient = class {
  constructor(clients = []) {
    __privateAdd(this, _transportClients, void 0);
    __privateSet(this, _transportClients, /* @__PURE__ */ new Map());
    clients = [new HttpDwnRpcClient(), ...clients];
    for (let client of clients) {
      for (let transportScheme of client.transportProtocols) {
        __privateGet(this, _transportClients).set(transportScheme, client);
      }
    }
  }
  get transportProtocols() {
    return Array.from(__privateGet(this, _transportClients).keys());
  }
  sendDwnRequest(request) {
    const url = new URL(request.dwnUrl);
    const transportClient = __privateGet(this, _transportClients).get(url.protocol);
    if (!transportClient) {
      const error = new Error(`no ${url.protocol} transport client available`);
      error.name = "NO_TRANSPORT_CLIENT";
      throw error;
    }
    return transportClient.sendDwnRequest(request);
  }
};
_transportClients = new WeakMap();
var HttpDwnRpcClient = class {
  get transportProtocols() {
    return ["http:", "https:"];
  }
  sendDwnRequest(request) {
    return __async(this, null, function* () {
      const requestId = uuidv4();
      const jsonRpcRequest = createJsonRpcRequest(requestId, "dwn.processMessage", {
        target: request.targetDid,
        message: request.message
      });
      const fetchOpts = {
        method: "POST",
        headers: {
          "dwn-request": JSON.stringify(jsonRpcRequest)
        }
      };
      if (request.data) {
        fetchOpts.headers["content-type"] = "application/octet-stream";
        fetchOpts["body"] = request.data;
      }
      const resp = yield fetch(request.dwnUrl, fetchOpts);
      let dwnRpcResponse;
      let dataStream;
      const { headers } = resp;
      if (headers.has("dwn-response")) {
        const jsonRpcResponse = parseJson(headers.get("dwn-response"));
        if (jsonRpcResponse == null) {
          throw new Error(`failed to parse json rpc response. dwn url: ${request.dwnUrl}`);
        }
        dataStream = resp.body;
        dwnRpcResponse = jsonRpcResponse;
      } else {
        const responseBody = yield resp.text();
        dwnRpcResponse = JSON.parse(responseBody);
      }
      if (dwnRpcResponse.error) {
        const { code, message } = dwnRpcResponse.error;
        throw new Error(`(${code}) - ${message}`);
      }
      const { reply } = dwnRpcResponse.result;
      if (dataStream) {
        reply["record"]["data"] = dataStream;
      }
      return reply;
    });
  }
};

// src/utils.ts
import { ReadableWebToNodeStream } from "readable-web-to-node-stream";
function blobToIsomorphicNodeReadable(blob) {
  return webReadableToIsomorphicNodeReadable(blob.stream());
}
function webReadableToIsomorphicNodeReadable(webReadable) {
  return new ReadableWebToNodeStream(webReadable);
}

// src/web5-user-agent.ts
var dwnMessageCreators = {
  [DwnInterfaceName.Events + DwnMethodName.Get]: EventsGet,
  [DwnInterfaceName.Messages + DwnMethodName.Get]: MessagesGet,
  [DwnInterfaceName.Records + DwnMethodName.Read]: RecordsRead,
  [DwnInterfaceName.Records + DwnMethodName.Query]: RecordsQuery,
  [DwnInterfaceName.Records + DwnMethodName.Write]: RecordsWrite,
  [DwnInterfaceName.Records + DwnMethodName.Delete]: RecordsDelete,
  [DwnInterfaceName.Protocols + DwnMethodName.Query]: ProtocolsQuery,
  [DwnInterfaceName.Protocols + DwnMethodName.Configure]: ProtocolsConfigure
};
var _getDwnMessage, getDwnMessage_fn, _constructDwnMessage, constructDwnMessage_fn, _getAuthorSignatureInput, getAuthorSignatureInput_fn;
var _Web5UserAgent = class {
  constructor(options) {
    __privateAdd(this, _getDwnMessage);
    __privateAdd(this, _constructDwnMessage);
    /**
     * constructs signature input required to sign DWeb Messages
     * @param authorDid
     * @returns {SignatureInput}
     */
    __privateAdd(this, _getAuthorSignatureInput);
    this.dwn = options.dwn;
    this.didResolver = options.didResolver;
    this.profileManager = options.profileManager;
    this.dwnRpcClient = new DwnRpcClient();
    if (options.syncManager) {
      this.syncManager = options.syncManager;
    }
  }
  /**
   * TODO: add jsdoc
   * @param options
   * @returns
   */
  static create(options) {
    return __async(this, null, function* () {
      options.dwn || (options.dwn = yield Dwn.create());
      options.profileManager || (options.profileManager = new ProfileApi());
      options.didResolver || (options.didResolver = new DidResolver({ methodResolvers: [new DidIonApi(), new DidKeyApi()] }));
      return new _Web5UserAgent(options);
    });
  }
  /**
   * TODO: add jsdoc
   * @param message
   * @returns
   */
  processDwnRequest(request) {
    return __async(this, null, function* () {
      const { message, dataStream } = yield __privateMethod(this, _constructDwnMessage, constructDwnMessage_fn).call(this, request);
      let reply;
      if (request.store !== false) {
        reply = yield this.dwn.processMessage(request.target, message, dataStream);
      } else {
        reply = { status: { code: 202, detail: "Accepted" } };
      }
      return {
        reply,
        message,
        messageCid: yield Message.getCid(message)
      };
    });
  }
  sendDwnRequest(request) {
    return __async(this, null, function* () {
      var _a;
      const dwnRpcRequest = { targetDid: request.target };
      let messageData;
      if ("messageCid" in request) {
        const { message, data } = yield __privateMethod(this, _getDwnMessage, getDwnMessage_fn).call(this, request.author, request.messageType, request.messageCid);
        dwnRpcRequest.message = message;
        messageData = data;
      } else {
        const { message } = yield __privateMethod(this, _constructDwnMessage, constructDwnMessage_fn).call(this, request);
        dwnRpcRequest.message = message;
        messageData = request.dataStream;
      }
      if (messageData) {
        dwnRpcRequest.data = messageData;
      }
      const didResolution = yield this.didResolver.resolve(request.target);
      if (!didResolution.didDocument) {
        if ((_a = didResolution.didResolutionMetadata) == null ? void 0 : _a.error) {
          throw new Error(`DID resolution error: ${didResolution.didResolutionMetadata.error}`);
        } else {
          throw new Error("DID resolution error: figure out error message");
        }
      }
      const [service] = didUtils.getServices(didResolution.didDocument, { id: "#dwn" });
      if (!service) {
        throw new Error(`${request.target} has no '#dwn' service endpoints`);
      }
      const { serviceEndpoint } = service;
      if (!serviceEndpoint["nodes"]) {
        throw new Error(`malformed '#dwn' service endpoint. expected nodes array`);
      }
      const { nodes } = serviceEndpoint;
      let dwnReply;
      let errorMessages = [];
      for (let node of nodes) {
        dwnRpcRequest.dwnUrl = node;
        try {
          dwnReply = yield this.dwnRpcClient.sendDwnRequest(dwnRpcRequest);
          break;
        } catch (e) {
          errorMessages.push({ url: node, message: e.message });
        }
      }
      if (!dwnReply) {
        throw new Error(JSON.stringify(errorMessages));
      }
      return {
        message: dwnRpcRequest.message,
        messageCid: yield Message.getCid(dwnRpcRequest.message),
        reply: dwnReply
      };
    });
  }
};
var Web5UserAgent = _Web5UserAgent;
_getDwnMessage = new WeakSet();
getDwnMessage_fn = function(author, messageType, messageCid) {
  return __async(this, null, function* () {
    const dwnSignatureInput = yield __privateMethod(this, _getAuthorSignatureInput, getAuthorSignatureInput_fn).call(this, author);
    const messagesGet = yield MessagesGet.create({
      authorizationSignatureInput: dwnSignatureInput,
      messageCids: [messageCid]
    });
    const result = yield this.dwn.processMessage(author, messagesGet.toJSON());
    const [messageEntry] = result.messages;
    if (!messageEntry) {
      throw new Error("TODO: figure out error message");
    }
    let { message } = messageEntry;
    if (!message) {
      throw new Error("TODO: message not found");
    }
    let dwnMessage = { message };
    if (messageType === "RecordsWrite") {
      const { encodedData } = messageEntry;
      message = message;
      if (encodedData) {
        const dataBytes = Encoder.base64UrlToBytes(encodedData);
        dwnMessage.data = new Blob([dataBytes]);
      } else {
        const recordsRead = yield RecordsRead.create({
          authorizationSignatureInput: dwnSignatureInput,
          recordId: message["recordId"]
        });
        const reply = yield this.dwn.processMessage(author, recordsRead.toJSON());
        if (reply.status.code >= 400) {
          const { status: { code, detail } } = reply;
          throw new Error(`(${code}) Failed to read data associated with record ${message["recordId"]}. ${detail}}`);
        } else {
          const dataBytes = yield DataStream.toBytes(reply.record.data);
          dwnMessage.data = new Blob([dataBytes]);
        }
      }
    }
    return dwnMessage;
  });
};
_constructDwnMessage = new WeakSet();
constructDwnMessage_fn = function(request) {
  return __async(this, null, function* () {
    var _a;
    const dwnSignatureInput = yield __privateMethod(this, _getAuthorSignatureInput, getAuthorSignatureInput_fn).call(this, request.author);
    let readableStream;
    if (request.messageType === "RecordsWrite") {
      const messageOptions = request.messageOptions;
      if (request.dataStream && !messageOptions.data) {
        const { dataStream } = request;
        let isomorphicNodeReadable;
        if (dataStream instanceof Blob) {
          isomorphicNodeReadable = blobToIsomorphicNodeReadable(dataStream);
          readableStream = blobToIsomorphicNodeReadable(dataStream);
        } else if (dataStream instanceof ReadableStream) {
          const [forCid, forProcessMessage] = dataStream.tee();
          isomorphicNodeReadable = webReadableToIsomorphicNodeReadable(forCid);
          readableStream = webReadableToIsomorphicNodeReadable(forProcessMessage);
        }
        messageOptions.dataCid = yield Cid.computeDagPbCidFromStream(isomorphicNodeReadable);
        (_a = messageOptions.dataSize) != null ? _a : messageOptions.dataSize = isomorphicNodeReadable["bytesRead"];
      }
    }
    const messageCreateInput = __spreadProps(__spreadValues({}, request.messageOptions), {
      authorizationSignatureInput: dwnSignatureInput
    });
    const messageCreator = dwnMessageCreators[request.messageType];
    const dwnMessage = yield messageCreator.create(messageCreateInput);
    return { message: dwnMessage.toJSON(), dataStream: readableStream };
  });
};
_getAuthorSignatureInput = new WeakSet();
getAuthorSignatureInput_fn = function(authorDid) {
  return __async(this, null, function* () {
    const profile = yield this.profileManager.getProfile(authorDid);
    if (!profile) {
      throw new Error("profile not found for author.");
    }
    const { keys } = profile.did;
    const [key] = keys;
    const { privateKeyJwk } = key;
    const kidFragment = privateKeyJwk.kid || key.id;
    const kid = `${profile.did.id}#${kidFragment}`;
    const dwnSignatureInput = {
      privateJwk: privateKeyJwk,
      protectedHeader: { alg: privateKeyJwk.crv, kid }
    };
    return dwnSignatureInput;
  });
};

// src/sync-api.ts
import { Level as Level3 } from "level";
import { utils as didUtils2 } from "@tbd54566975/dids";
import { DataStream as DataStream2, EventsGet as EventsGet2, MessagesGet as MessagesGet2, Encoder as Encoder2, RecordsRead as RecordsRead2 } from "@tbd54566975/dwn-sdk-js";
var _db, _dwn, _didResolver, _profileManager, _dwnRpcClient, _defaultOptions, _getDwnMessage2, getDwnMessage_fn2, _getAuthorSignatureInput2, getAuthorSignatureInput_fn2, _messageExists, messageExists_fn, _addMessage, addMessage_fn, _getMessageStore, getMessageStore_fn, _getWatermarkStore, getWatermarkStore_fn, _getPushQueue, getPushQueue_fn, _getPullQueue, getPullQueue_fn, _getDwnMessageType, getDwnMessageType_fn;
var _SyncApi = class {
  constructor(options) {
    __privateAdd(this, _getDwnMessage2);
    /**
     * constructs signature input required to sign DWeb Messages
     * @param authorDid
     * @returns {SignatureInput}
     */
    __privateAdd(this, _getAuthorSignatureInput2);
    __privateAdd(this, _messageExists);
    __privateAdd(this, _addMessage);
    __privateAdd(this, _getMessageStore);
    __privateAdd(this, _getWatermarkStore);
    __privateAdd(this, _getPushQueue);
    __privateAdd(this, _getPullQueue);
    // TODO: export BaseMessage from dwn-sdk.
    __privateAdd(this, _getDwnMessageType);
    __privateAdd(this, _db, void 0);
    __privateAdd(this, _dwn, void 0);
    __privateAdd(this, _didResolver, void 0);
    __privateAdd(this, _profileManager, void 0);
    __privateAdd(this, _dwnRpcClient, void 0);
    options = __spreadValues(__spreadValues({}, __privateGet(_SyncApi, _defaultOptions)), options);
    __privateSet(this, _dwn, options.dwn);
    __privateSet(this, _didResolver, options.didResolver);
    __privateSet(this, _profileManager, options.profileManager);
    __privateSet(this, _db, new Level3(options.storeLocation));
    __privateSet(this, _dwnRpcClient, new DwnRpcClient());
  }
  clear() {
    return __async(this, null, function* () {
      return __privateGet(this, _db).clear();
    });
  }
  registerProfile(did) {
    return __async(this, null, function* () {
      const registeredProfiles = __privateGet(this, _db).sublevel("registeredProfiles");
      yield registeredProfiles.put(did, "");
    });
  }
  enqueuePush() {
    return __async(this, null, function* () {
      const profileDids = yield __privateGet(this, _db).sublevel("registeredProfiles").keys().all();
      const syncStates = [];
      for (let did of profileDids) {
        const { didDocument } = yield __privateGet(this, _didResolver).resolve(did);
        const [service] = didUtils2.getServices(didDocument, { id: "#dwn", type: "DecentralizedWebNode" });
        if (!service) {
          continue;
        }
        const { nodes } = service.serviceEndpoint;
        for (let node of nodes) {
          const watermark = yield this.getWatermark(did, node, "push");
          syncStates.push({ did, dwnUrl: node, watermark });
        }
      }
      for (let syncState of syncStates) {
        const signatureInput = yield __privateMethod(this, _getAuthorSignatureInput2, getAuthorSignatureInput_fn2).call(this, syncState.did);
        const eventsGet = yield EventsGet2.create({
          watermark: syncState.watermark,
          authorizationSignatureInput: signatureInput
        });
        const eventsReply = yield __privateGet(this, _dwn).processMessage(syncState.did, eventsGet.toJSON());
        const putOps = [];
        for (let event of eventsReply.events) {
          const pushKey = `${syncState.did}~${syncState.dwnUrl}~${event.messageCid}`;
          const putOp = { type: "put", key: pushKey, value: event.watermark };
          putOps.push(putOp);
        }
        const pushQueue = __privateMethod(this, _getPushQueue, getPushQueue_fn).call(this);
        yield pushQueue.batch(putOps);
      }
    });
  }
  getEvents(did, watermark, dwnUrl) {
    return __async(this, null, function* () {
      const signatureInput = yield __privateMethod(this, _getAuthorSignatureInput2, getAuthorSignatureInput_fn2).call(this, did);
      const eventsGet = yield EventsGet2.create({
        watermark,
        authorizationSignatureInput: signatureInput
      });
      let events;
      if (dwnUrl === "local") {
        const reply = yield __privateGet(this, _dwn).processMessage(did, eventsGet.toJSON());
        ({ events } = reply);
      } else {
        const reply = yield __privateGet(this, _dwnRpcClient).sendDwnRequest({
          dwnUrl,
          targetDid: did,
          message: eventsGet
        });
        ({ events } = reply);
      }
      return events;
    });
  }
  push() {
    return __async(this, null, function* () {
      yield this.enqueuePush();
      const pushQueue = __privateMethod(this, _getPushQueue, getPushQueue_fn).call(this);
      const pushJobs = yield pushQueue.iterator().all();
      const errored = /* @__PURE__ */ new Set();
      const delOps = [];
      for (let job of pushJobs) {
        const [key, watermark] = job;
        const [did, dwnUrl, messageCid] = key.split("~");
        if (errored.has(dwnUrl)) {
          continue;
        }
        const dwnMessage = yield __privateMethod(this, _getDwnMessage2, getDwnMessage_fn2).call(this, did, messageCid);
        if (!dwnMessage) {
          delOps.push({ type: "del", key });
          yield this.setWatermark(did, dwnUrl, "push", watermark);
          yield __privateMethod(this, _addMessage, addMessage_fn).call(this, did, messageCid);
          continue;
        }
        try {
          const reply = yield __privateGet(this, _dwnRpcClient).sendDwnRequest({
            dwnUrl,
            targetDid: did,
            data: dwnMessage.data,
            message: dwnMessage.message
          });
          if (reply.status.code === 202 || reply.status.code === 409) {
            delOps.push({ type: "del", key });
            yield this.setWatermark(did, dwnUrl, "push", watermark);
            yield __privateMethod(this, _addMessage, addMessage_fn).call(this, did, messageCid);
          }
        } catch (e) {
          errored.add(dwnUrl);
        }
      }
      yield pushQueue.batch(delOps);
    });
  }
  enqueuePull() {
    return __async(this, null, function* () {
      const profileDids = yield __privateGet(this, _db).sublevel("registeredProfiles").keys().all();
      const syncStates = [];
      for (let did of profileDids) {
        const { didDocument } = yield __privateGet(this, _didResolver).resolve(did);
        const [service] = didUtils2.getServices(didDocument, { id: "#dwn", type: "DecentralizedWebNode" });
        if (!service) {
          continue;
        }
        const { nodes } = service.serviceEndpoint;
        for (let node of nodes) {
          const watermark = yield this.getWatermark(did, node, "pull");
          syncStates.push({ did, dwnUrl: node, watermark });
        }
      }
      const pullOps = [];
      for (let syncState of syncStates) {
        const signatureInput = yield __privateMethod(this, _getAuthorSignatureInput2, getAuthorSignatureInput_fn2).call(this, syncState.did);
        const eventsGet = yield EventsGet2.create({
          watermark: syncState.watermark,
          authorizationSignatureInput: signatureInput
        });
        let reply;
        try {
          reply = yield __privateGet(this, _dwnRpcClient).sendDwnRequest({
            dwnUrl: syncState.dwnUrl,
            targetDid: syncState.did,
            message: eventsGet
          });
        } catch (e) {
          continue;
        }
        for (let event of reply.events) {
          const pullKey = `${syncState.did}~${syncState.dwnUrl}~${event.messageCid}`;
          const pullOp = { type: "put", key: pullKey, value: event.watermark };
          pullOps.push(pullOp);
        }
        if (pullOps.length > 0) {
          const pullQueue = __privateMethod(this, _getPullQueue, getPullQueue_fn).call(this);
          pullQueue.batch(pullOps);
        }
      }
    });
  }
  pull() {
    return __async(this, null, function* () {
      yield this.enqueuePull();
      const pullQueue = __privateMethod(this, _getPullQueue, getPullQueue_fn).call(this);
      const pullJobs = yield pullQueue.iterator().all();
      const delOps = [];
      const errored = /* @__PURE__ */ new Set();
      for (let job of pullJobs) {
        const [key, watermark] = job;
        const [did, dwnUrl, messageCid] = key.split("~");
        if (errored.has(dwnUrl)) {
          continue;
        }
        const messageExists = yield __privateMethod(this, _messageExists, messageExists_fn).call(this, did, messageCid);
        if (messageExists) {
          yield this.setWatermark(did, dwnUrl, "pull", watermark);
          delOps.push({ type: "del", key });
          continue;
        }
        const signatureInput = yield __privateMethod(this, _getAuthorSignatureInput2, getAuthorSignatureInput_fn2).call(this, did);
        const messagesGet = yield MessagesGet2.create({
          messageCids: [messageCid],
          authorizationSignatureInput: signatureInput
        });
        let reply;
        try {
          reply = yield __privateGet(this, _dwnRpcClient).sendDwnRequest({
            dwnUrl,
            targetDid: did,
            message: messagesGet
          });
        } catch (e) {
          errored.add(dwnUrl);
          continue;
        }
        for (let entry of reply.messages) {
          if (entry.error || !entry.message) {
            console.warn(`message ${messageCid} not found. entry: ${JSON.stringify(entry, null, 2)} ignoring..`);
            yield this.setWatermark(did, dwnUrl, "pull", watermark);
            yield __privateMethod(this, _addMessage, addMessage_fn).call(this, did, messageCid);
            delOps.push({ type: "del", key });
            continue;
          }
          const messageType = __privateMethod(this, _getDwnMessageType, getDwnMessageType_fn).call(this, entry.message);
          let dataStream;
          if (messageType === "RecordsWrite") {
            const { encodedData } = entry;
            const message = entry.message;
            if (encodedData) {
              const dataBytes = Encoder2.base64UrlToBytes(encodedData);
              dataStream = DataStream2.fromBytes(dataBytes);
            } else {
              const recordsRead = yield RecordsRead2.create({
                authorizationSignatureInput: signatureInput,
                recordId: message["recordId"]
              });
              const recordsReadReply = yield __privateGet(this, _dwnRpcClient).sendDwnRequest({
                targetDid: did,
                dwnUrl,
                message: recordsRead
              });
              if (recordsReadReply.status.code >= 400) {
                const pruneReply = yield __privateGet(this, _dwn).synchronizePrunedInitialRecordsWrite(did, message);
                if (pruneReply.status.code === 202 || pruneReply.status.code === 409) {
                  yield this.setWatermark(did, dwnUrl, "pull", watermark);
                  yield __privateMethod(this, _addMessage, addMessage_fn).call(this, did, messageCid);
                  delOps.push({ type: "del", key });
                  continue;
                } else {
                  throw new Error(`Failed to sync tombstone. message cid: ${messageCid}`);
                }
              } else {
                dataStream = webReadableToIsomorphicNodeReadable(recordsReadReply.record.data);
              }
            }
          }
          const pullReply = yield __privateGet(this, _dwn).processMessage(did, entry.message, dataStream);
          if (pullReply.status.code === 202 || pullReply.status.code === 409) {
            yield this.setWatermark(did, dwnUrl, "pull", watermark);
            yield __privateMethod(this, _addMessage, addMessage_fn).call(this, did, messageCid);
            delOps.push({ type: "del", key });
          }
        }
      }
      yield pullQueue.batch(delOps);
    });
  }
  getWatermark(did, dwnUrl, direction) {
    return __async(this, null, function* () {
      const wmKey = `${did}~${dwnUrl}~${direction}`;
      const watermarkStore = __privateMethod(this, _getWatermarkStore, getWatermarkStore_fn).call(this);
      try {
        return yield watermarkStore.get(wmKey);
      } catch (e) {
        if (e.code === "LEVEL_NOT_FOUND") {
          return void 0;
        }
      }
    });
  }
  setWatermark(did, dwnUrl, direction, watermark) {
    return __async(this, null, function* () {
      const wmKey = `${did}~${dwnUrl}~${direction}`;
      const watermarkStore = __privateMethod(this, _getWatermarkStore, getWatermarkStore_fn).call(this);
      return watermarkStore.put(wmKey, watermark);
    });
  }
};
var SyncApi = _SyncApi;
_db = new WeakMap();
_dwn = new WeakMap();
_didResolver = new WeakMap();
_profileManager = new WeakMap();
_dwnRpcClient = new WeakMap();
_defaultOptions = new WeakMap();
_getDwnMessage2 = new WeakSet();
getDwnMessage_fn2 = function(author, messageCid) {
  return __async(this, null, function* () {
    const dwnSignatureInput = yield __privateMethod(this, _getAuthorSignatureInput2, getAuthorSignatureInput_fn2).call(this, author);
    const messagesGet = yield MessagesGet2.create({
      authorizationSignatureInput: dwnSignatureInput,
      messageCids: [messageCid]
    });
    const result = yield __privateGet(this, _dwn).processMessage(author, messagesGet.toJSON());
    const [messageEntry] = result.messages;
    if (!messageEntry) {
      return void 0;
    }
    let { message } = messageEntry;
    if (!message) {
      return void 0;
    }
    let dwnMessage = { message };
    const messageType = `${message.descriptor.interface}${message.descriptor.method}`;
    if (messageType === "RecordsWrite") {
      const { encodedData } = messageEntry;
      message = message;
      if (encodedData) {
        const dataBytes = Encoder2.base64UrlToBytes(encodedData);
        dwnMessage.data = new Blob([dataBytes]);
      } else {
        const recordsRead = yield RecordsRead2.create({
          authorizationSignatureInput: dwnSignatureInput,
          recordId: message["recordId"]
        });
        const reply = yield __privateGet(this, _dwn).processMessage(author, recordsRead.toJSON());
        if (reply.status.code === 200) {
          const dataBytes = yield DataStream2.toBytes(reply.record.data);
          dwnMessage.data = new Blob([dataBytes]);
        } else if (reply.status.code >= 500) {
          const { status: { code, detail } } = reply;
          throw new Error(`(${code}) Failed to read data associated with record ${message["recordId"]}. ${detail}}`);
        }
      }
    }
    return dwnMessage;
  });
};
_getAuthorSignatureInput2 = new WeakSet();
getAuthorSignatureInput_fn2 = function(authorDid) {
  return __async(this, null, function* () {
    const profile = yield __privateGet(this, _profileManager).getProfile(authorDid);
    if (!profile) {
      throw new Error("profile not found for author.");
    }
    const { keys } = profile.did;
    const [key] = keys;
    const { privateKeyJwk } = key;
    const kidFragment = privateKeyJwk.kid || key.id;
    const kid = `${profile.did.id}#${kidFragment}`;
    const dwnSignatureInput = {
      privateJwk: privateKeyJwk,
      protectedHeader: { alg: privateKeyJwk.crv, kid }
    };
    return dwnSignatureInput;
  });
};
_messageExists = new WeakSet();
messageExists_fn = function(did, messageCid) {
  return __async(this, null, function* () {
    const messageStore = __privateMethod(this, _getMessageStore, getMessageStore_fn).call(this, did);
    const hashedKey = /* @__PURE__ */ new Set([messageCid]);
    const itr = messageStore.keys({ lte: messageCid, limit: 1 });
    try {
      for (var iter = __forAwait(itr), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        let key = temp.value;
        if (hashedKey.has(key)) {
          return true;
        } else {
          return false;
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
};
_addMessage = new WeakSet();
addMessage_fn = function(did, messageCid) {
  return __async(this, null, function* () {
    const messageStore = __privateMethod(this, _getMessageStore, getMessageStore_fn).call(this, did);
    return messageStore.put(messageCid, "");
  });
};
_getMessageStore = new WeakSet();
getMessageStore_fn = function(did) {
  return __privateGet(this, _db).sublevel("history").sublevel(did).sublevel("messages");
};
_getWatermarkStore = new WeakSet();
getWatermarkStore_fn = function() {
  return __privateGet(this, _db).sublevel("watermarks");
};
_getPushQueue = new WeakSet();
getPushQueue_fn = function() {
  return __privateGet(this, _db).sublevel("pushQueue");
};
_getPullQueue = new WeakSet();
getPullQueue_fn = function() {
  return __privateGet(this, _db).sublevel("pullQueue");
};
_getDwnMessageType = new WeakSet();
getDwnMessageType_fn = function(message) {
  return `${message.descriptor.interface}${message.descriptor.method}`;
};
__privateAdd(SyncApi, _defaultOptions, {
  storeLocation: "data/agent/sync-store"
});
export {
  ProfileApi,
  ProfileStore,
  SyncApi,
  Web5UserAgent
};
//# sourceMappingURL=main.mjs.map
