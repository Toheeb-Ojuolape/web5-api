"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ed25519: () => ed25519_exports,
  utils: () => utils_exports
});
module.exports = __toCommonJS(main_exports);

// src/ed25519.ts
var ed25519_exports = {};
__export(ed25519_exports, {
  deriveX25519KeyPair: () => deriveX25519KeyPair,
  generateKeyPair: () => generateKeyPair,
  keyPairToJwk: () => keyPairToJwk,
  sign: () => sign,
  verify: () => verify
});
var import_tweetnacl = __toESM(require("tweetnacl"), 1);
var import_ed2curve = __toESM(require("ed2curve"), 1);

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  MULTICODEC_HEADERS: () => MULTICODEC_HEADERS,
  base64UrlToBytes: () => base64UrlToBytes,
  bytesToBase58btcMultibase: () => bytesToBase58btcMultibase,
  bytesToBase64Url: () => bytesToBase64Url
});
var import_base64 = require("multiformats/bases/base64");
var import_base58 = require("multiformats/bases/base58");
var MULTICODEC_HEADERS = {
  ED25519: {
    PUB: new Uint8Array([237, 1]),
    PRIV: new Uint8Array([128, 38])
  },
  X25519: {
    PUB: new Uint8Array([236, 1]),
    PRIV: new Uint8Array([130, 38])
  },
  NOOP: new Uint8Array([])
};
function bytesToBase64Url(bytes) {
  return import_base64.base64url.baseEncode(bytes);
}
function base64UrlToBytes(base64urlString) {
  return import_base64.base64url.baseDecode(base64urlString);
}
function bytesToBase58btcMultibase(header, bytes) {
  const multibaseBytes = new Uint8Array(header.length + bytes.length);
  multibaseBytes.set(header);
  multibaseBytes.set(bytes);
  return import_base58.base58btc.encode(multibaseBytes);
}

// src/ed25519.ts
function generateKeyPair() {
  const ed25519KeyPair = import_tweetnacl.default.sign.keyPair();
  return { publicKey: ed25519KeyPair.publicKey, privateKey: ed25519KeyPair.secretKey };
}
function deriveX25519KeyPair(ed25519KeyPair) {
  const x25519KeyPair = import_ed2curve.default.convertKeyPair({ publicKey: ed25519KeyPair.publicKey, secretKey: ed25519KeyPair.privateKey });
  if (!x25519KeyPair) {
    throw new Error("failed to derive x25519 key pair.");
  }
  return { publicKey: x25519KeyPair.publicKey, privateKey: x25519KeyPair.secretKey };
}
function keyPairToJwk(keyPair, kid, overrides = { crv: "Ed25519" }) {
  const jwk = { kty: "OKP", crv: overrides.crv, kid };
  const encodedPublicKey = bytesToBase64Url(keyPair.publicKey);
  const publicKeyJwk = __spreadProps(__spreadValues({}, jwk), { x: encodedPublicKey });
  const encodedSecretKey = bytesToBase64Url(keyPair.privateKey);
  const privateKeyJwk = __spreadProps(__spreadValues({}, publicKeyJwk), { d: encodedSecretKey });
  return { publicKeyJwk, privateKeyJwk };
}
function sign(options) {
  const { payload, privateKeyJwk } = options;
  const privateKeyBytes = base64UrlToBytes(privateKeyJwk.d);
  if (privateKeyJwk.crv !== "Ed25519") {
    throw new Error("crv must be Ed25519");
  }
  const signedData = import_tweetnacl.default.sign(payload, privateKeyBytes);
  return signedData.slice(0, import_tweetnacl.default.sign.signatureLength);
}
function verify(options) {
  return __async(this, null, function* () {
    const { signature, payload, publicKeyJwk } = options;
    const publicKeyBytes = base64UrlToBytes(publicKeyJwk.x);
    if (publicKeyJwk.crv !== "Ed25519") {
      throw new Error("crv must be Ed25519");
    }
    const signedData = new Uint8Array(signature.length + payload.length);
    signedData.set(signature);
    signedData.set(payload, signature.length);
    const result = import_tweetnacl.default.sign.open(signedData, publicKeyBytes);
    return !!result;
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ed25519,
  utils
});
//# sourceMappingURL=main.cjs.map
