var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/ed25519.ts
var ed25519_exports = {};
__export(ed25519_exports, {
  deriveX25519KeyPair: () => deriveX25519KeyPair,
  generateKeyPair: () => generateKeyPair,
  keyPairToJwk: () => keyPairToJwk,
  sign: () => sign,
  verify: () => verify
});
import nacl from "tweetnacl";
import ed2curve from "ed2curve";

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  MULTICODEC_HEADERS: () => MULTICODEC_HEADERS,
  base64UrlToBytes: () => base64UrlToBytes,
  bytesToBase58btcMultibase: () => bytesToBase58btcMultibase,
  bytesToBase64Url: () => bytesToBase64Url
});
import { base64url } from "multiformats/bases/base64";
import { base58btc } from "multiformats/bases/base58";
var MULTICODEC_HEADERS = {
  ED25519: {
    PUB: new Uint8Array([237, 1]),
    PRIV: new Uint8Array([128, 38])
  },
  X25519: {
    PUB: new Uint8Array([236, 1]),
    PRIV: new Uint8Array([130, 38])
  },
  NOOP: new Uint8Array([])
};
function bytesToBase64Url(bytes) {
  return base64url.baseEncode(bytes);
}
function base64UrlToBytes(base64urlString) {
  return base64url.baseDecode(base64urlString);
}
function bytesToBase58btcMultibase(header, bytes) {
  const multibaseBytes = new Uint8Array(header.length + bytes.length);
  multibaseBytes.set(header);
  multibaseBytes.set(bytes);
  return base58btc.encode(multibaseBytes);
}

// src/ed25519.ts
function generateKeyPair() {
  const ed25519KeyPair = nacl.sign.keyPair();
  return { publicKey: ed25519KeyPair.publicKey, privateKey: ed25519KeyPair.secretKey };
}
function deriveX25519KeyPair(ed25519KeyPair) {
  const x25519KeyPair = ed2curve.convertKeyPair({ publicKey: ed25519KeyPair.publicKey, secretKey: ed25519KeyPair.privateKey });
  if (!x25519KeyPair) {
    throw new Error("failed to derive x25519 key pair.");
  }
  return { publicKey: x25519KeyPair.publicKey, privateKey: x25519KeyPair.secretKey };
}
function keyPairToJwk(keyPair, kid, overrides = { crv: "Ed25519" }) {
  const jwk = { kty: "OKP", crv: overrides.crv, kid };
  const encodedPublicKey = bytesToBase64Url(keyPair.publicKey);
  const publicKeyJwk = __spreadProps(__spreadValues({}, jwk), { x: encodedPublicKey });
  const encodedSecretKey = bytesToBase64Url(keyPair.privateKey);
  const privateKeyJwk = __spreadProps(__spreadValues({}, publicKeyJwk), { d: encodedSecretKey });
  return { publicKeyJwk, privateKeyJwk };
}
function sign(options) {
  const { payload, privateKeyJwk } = options;
  const privateKeyBytes = base64UrlToBytes(privateKeyJwk.d);
  if (privateKeyJwk.crv !== "Ed25519") {
    throw new Error("crv must be Ed25519");
  }
  const signedData = nacl.sign(payload, privateKeyBytes);
  return signedData.slice(0, nacl.sign.signatureLength);
}
function verify(options) {
  return __async(this, null, function* () {
    const { signature, payload, publicKeyJwk } = options;
    const publicKeyBytes = base64UrlToBytes(publicKeyJwk.x);
    if (publicKeyJwk.crv !== "Ed25519") {
      throw new Error("crv must be Ed25519");
    }
    const signedData = new Uint8Array(signature.length + payload.length);
    signedData.set(signature);
    signedData.set(payload, signature.length);
    const result = nacl.sign.open(signedData, publicKeyBytes);
    return !!result;
  });
}
export {
  ed25519_exports as ed25519,
  utils_exports as utils
};
//# sourceMappingURL=main.mjs.map
