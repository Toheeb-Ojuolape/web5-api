var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DidIonApi: () => DidIonApi,
  DidKeyApi: () => DidKeyApi,
  DidResolver: () => DidResolver,
  utils: () => utils_exports
});
module.exports = __toCommonJS(main_exports);

// src/did-ion.ts
var import_ion_tools = require("@decentralized-identity/ion-tools");
var DidIonApi = class {
  /**
   * @param resolutionEndpoint optional custom URL to send DID resolution request to
   */
  constructor(resolutionEndpoint = "https://discover.did.msidentity.com/1.0/identifiers/") {
    this.resolutionEndpoint = resolutionEndpoint;
  }
  get methodName() {
    return "ion";
  }
  // TODO: discuss. need to normalize what's returned from `create`. DidIon.create and DidKey.create return different things.
  create() {
    return __async(this, arguments, function* (options = {}) {
      var _a, _b;
      options.keys || (options.keys = [
        {
          id: "dwn",
          type: "JsonWebKey2020",
          keyPair: yield (0, import_ion_tools.generateKeyPair)(),
          purposes: ["authentication"]
        }
      ]);
      const didOptions = { publicKeys: [] };
      if (options.services) {
        didOptions.services = options.services;
      }
      for (let key of options.keys) {
        const publicKey = __spreadValues({}, key);
        publicKey.publicKeyJwk = key.keyPair.publicJwk;
        delete publicKey.keyPair;
        didOptions.publicKeys.push(publicKey);
      }
      const did = new import_ion_tools.DID({ content: didOptions });
      const didState = {
        id: yield did.getURI(),
        internalId: yield did.getURI("short"),
        methodData: yield did.getAllOperations()
      };
      const didDocument = {
        "@context": "https://www.w3.org/ns/did/v1",
        id: didState.id,
        verificationMethod: []
      };
      for (let key of didState.methodData[0].content.publicKeys) {
        const verificationMethod = {
          id: `#${key.id}`,
          controller: didState.id,
          type: key.type,
          publicKeyJwk: key.publicKeyJwk
        };
        didDocument.verificationMethod.push(verificationMethod);
        for (let purpose of key.purposes) {
          if (didDocument[purpose]) {
            didDocument[purpose].push(key.id);
          } else {
            didDocument[purpose] = [`#${key.id}`];
          }
        }
      }
      for (let service of ((_b = (_a = didState.methodData[0]) == null ? void 0 : _a.content) == null ? void 0 : _b.services) || []) {
        const serviceEntry = {
          id: `#${service.id}`,
          type: service.type,
          serviceEndpoint: __spreadValues({}, service.serviceEndpoint)
        };
        if (didDocument.service) {
          didDocument.service.push(serviceEntry);
        } else {
          didDocument.service = [serviceEntry];
        }
      }
      const keys = [];
      for (let keyOption of options.keys) {
        const key = {
          id: `${didState.id}#${keyOption.id}`,
          type: keyOption.type,
          controller: didState.id,
          publicKeyJwk: keyOption.keyPair.publicJwk,
          privateKeyJwk: keyOption.keyPair.privateJwk
        };
        keys.push(key);
      }
      return {
        id: didState.id,
        internalId: didState.internalId,
        didDocument,
        methodData: didState.methodData,
        keys
        // TODO: Remove keys once KeyManager/KeyStore implemented since everything BUT privateKeyJwk is already in the returned didDocument.
      };
    });
  }
  resolve(did) {
    return __async(this, null, function* () {
      const resolutionUrl = new URL("./" + did, this.resolutionEndpoint).toString();
      const response = yield fetch(resolutionUrl);
      if (response.status !== 200) {
        throw new Error(`unable to resolve ${did}, got http status ${response.status}`);
      }
      const didResolutionResult = yield response.json();
      return didResolutionResult;
    });
  }
  /**
   * Generates two key pairs used for authorization and encryption purposes
   * when interfacing with DWNs. The IDs of these keys are referenced in the
   * service object that includes the dwnUrls provided.
   */
  generateDwnConfiguration(dwnUrls) {
    return __async(this, null, function* () {
      return DidIonApi.generateDwnConfiguration(dwnUrls);
    });
  }
  /**
   * Generates two key pairs used for authorization and encryption purposes
   * when interfacing with DWNs. The IDs of these keys are referenced in the
   * service object that includes the dwnUrls provided.
   */
  static generateDwnConfiguration(dwnUrls) {
    return __async(this, null, function* () {
      const keys = [{
        id: "authz",
        type: "JsonWebKey2020",
        keyPair: yield (0, import_ion_tools.generateKeyPair)("secp256k1"),
        purposes: ["authentication"]
      }, {
        id: "enc",
        type: "JsonWebKey2020",
        keyPair: yield (0, import_ion_tools.generateKeyPair)("secp256k1"),
        purposes: ["keyAgreement"]
      }];
      const services = [{
        "id": "dwn",
        "type": "DecentralizedWebNode",
        "serviceEndpoint": {
          "nodes": dwnUrls,
          "messageAuthorizationKeys": ["#authz"],
          "recordEncryptionKeys": ["#enc"]
        }
      }];
      return { keys, services };
    });
  }
};

// src/did-key.ts
var import_crypto = require("@tbd54566975/crypto");
var import_dwn_sdk_js = require("@tbd54566975/dwn-sdk-js");

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  DID_REGEX: () => DID_REGEX,
  createVerificationMethodWithPrivateKeyJwk: () => createVerificationMethodWithPrivateKeyJwk,
  getServices: () => getServices,
  parseDid: () => parseDid
});
function parseDid(did) {
  if (!DID_REGEX.test(did)) {
    throw new Error("Invalid DID");
  }
  const [didString] = did.split("#");
  const [, method, id] = didString.split(":", 3);
  return { method, id };
}
function createVerificationMethodWithPrivateKeyJwk(id, keyPairJwk) {
  const { publicKeyJwk, privateKeyJwk } = keyPairJwk;
  return {
    id: `${id}#${keyPairJwk.publicKeyJwk.kid}`,
    type: "JsonWebKey2020",
    controller: id,
    publicKeyJwk,
    privateKeyJwk
  };
}
function getServices(didDocument, options = {}) {
  var _a, _b;
  return (_b = (_a = didDocument == null ? void 0 : didDocument.service) == null ? void 0 : _a.filter((service) => {
    if ((options == null ? void 0 : options.id) && service.id !== options.id)
      return false;
    if ((options == null ? void 0 : options.type) && service.type !== options.type)
      return false;
    return true;
  })) != null ? _b : [];
}
var DID_REGEX = /^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(\/[^#?]*)?([?][^#]*)?(#.*)?$/;

// src/did-key.ts
var didKeyResolver = new import_dwn_sdk_js.DidKeyResolver();
var DidKeyApi = class {
  get methodName() {
    return "key";
  }
  create() {
    return __async(this, arguments, function* (_options = {}) {
      const verificationKeyPair = import_crypto.ed25519.generateKeyPair();
      const keyAgreementKeyPair = import_crypto.ed25519.deriveX25519KeyPair(verificationKeyPair);
      const verificationKeyId = import_crypto.utils.bytesToBase58btcMultibase(import_crypto.utils.MULTICODEC_HEADERS.ED25519.PUB, verificationKeyPair.publicKey);
      const keyAgreementKeyId = import_crypto.utils.bytesToBase58btcMultibase(import_crypto.utils.MULTICODEC_HEADERS.X25519.PUB, keyAgreementKeyPair.publicKey);
      const id = `did:key:${verificationKeyId}`;
      const verificationJwkPair = import_crypto.ed25519.keyPairToJwk(verificationKeyPair, verificationKeyId);
      const verificationKey = createVerificationMethodWithPrivateKeyJwk(id, verificationJwkPair);
      const keyAgreementJwkPair = import_crypto.ed25519.keyPairToJwk(keyAgreementKeyPair, keyAgreementKeyId, { crv: "X25519" });
      const keyAgreementKey = createVerificationMethodWithPrivateKeyJwk(id, keyAgreementJwkPair);
      return {
        id,
        internalId: id,
        // didDocument : {},  //! TODO: Add DidDocument to object returned.
        keys: [verificationKey, keyAgreementKey],
        methodData: {}
      };
    });
  }
  resolve(did) {
    return didKeyResolver.resolve(did);
  }
};

// src/nop-cache.ts
var nopCache = {
  get: function(_key) {
    return;
  },
  set: function(_key, _value) {
    return;
  },
  delete: function(_key) {
    return;
  },
  clear: function() {
    return;
  },
  close: function() {
    return;
  }
};

// src/did-resolver.ts
var DidResolver = class {
  constructor(options) {
    this.methodResolverMap = /* @__PURE__ */ new Map();
    this.cache = options.cache || nopCache;
    for (let methodResolver of options.methodResolvers) {
      this.methodResolverMap.set(methodResolver.methodName, methodResolver);
    }
  }
  resolve(did) {
    return __async(this, null, function* () {
      const { method } = parseDid(did);
      const resolver = this.methodResolverMap.get(method);
      if (!resolver) {
        throw new Error(`no resolver for ${method}`);
      }
      const cachedResolution = yield this.cache.get(did);
      if (cachedResolution) {
        return cachedResolution;
      } else {
        const didResolutionResult = yield resolver.resolve(did);
        yield this.cache.set(did, didResolutionResult);
        return didResolutionResult;
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DidIonApi,
  DidKeyApi,
  DidResolver,
  utils
});
//! i know dwn-sdk-js has a resolver that includes both creation and resolving. but they're slightly different and we really
//! need to settle on what the normalized result of did creation is.
//# sourceMappingURL=main.cjs.map
